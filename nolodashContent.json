[{"categoryHeading":"Array","entries":[{"name":"chunk","manifest":{"fnSignature":"_.chunk(array, size?)","lodashLink":"https://lodash.com/docs/4.17.15#chunk","summary":"Creates an array of elements split into groups the length of `size`. If `array` can't be split evenly, the final chunk will be the remaining elements."},"description":"```javascript\nfunction chunk(array, size = 1) {\n  const result = [];\n  for (let i = 0; i < array.length; i += size) {\n    result.push(array.slice(i, i + size));\n  }\n  return result;\n}\n```\n","src":null,"test":""},{"name":"compact","manifest":{"fnSignature":"_.compact(array)","lodashLink":"https://lodash.com/docs/4.17.15#compact","summary":"Creates an array with all falsey values removed. The values `false`, `null`, `0`, `\"\"`, `undefined`, and `NaN` are falsey."},"description":"All of these solutions are equivalent. Pick the one you find to be the most readable.\n\n```javascript\narray.filter(value => !!value);\n\narray.filter(value => value);\n\narray.filter(Boolean);\n```\n","src":null,"test":""},{"name":"concat","manifest":{"fnSignature":"_.concat(array, ...values)","lodashLink":"https://lodash.com/docs/4.17.15#concat","summary":"Creates a new array concatenating `array` with any additional arrays and/or values."},"description":"```javascript\nconst result = [...array1, ...array2, ...array3];\n```\n\nThis solution above only works on arrays and other iterables. If some of your values might not be arrays, you can use this solution instead:\n\n```javascript\nconst array1 = [1, 2, 3];\nconst value1 = 4;\nconst array2 = [5, 6, 7];\n\nconst result = [array1, value1, array2].flat();\n\n// Expected output: [1, 2, 3, 4, 5, 6, 7]\n```\n","src":null,"test":""},{"name":"difference","manifest":{"fnSignature":"_.difference(array, values?)","lodashLink":"https://lodash.com/docs/4.17.15#difference","summary":"Creates an array of `array` values not included in the other given arrays using `SameValueZero` for equality comparisons. The order and references of result values are determined by the first array."},"description":"To subtract everything in array2 from array1, use the following:\n\n```javascript\narray1.filter(x => !array2.includes(x));\n```\n\nRemember that `.includes()` has an `O(n)` lookup time. If you're dealing with larger arrays, make sure to convert the target array into a set first (a set's `.has()` method has `O(1)` lookup time).\n\n```javascript\nconst set2 = new Set(array2);\nconst result = array1.filter(x => !set2.has(x));\n```\n\nBoth `array.includes()` and `set.has()` use [the SameValueZero comparison algorithm](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#same-value-zero_equality) under-the-hood as well, just like Lodash's `_.difference()`.\n","src":null,"test":""},{"name":"differenceBy","manifest":{"fnSignature":"_.differenceBy(array, values?, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#differenceBy","summary":"This method is like `_.difference` except that it accepts `iteratee` which is invoked for each element of `array` and `values` to generate the criterion by which they're compared. The order and references of result values are determined by the first array."},"description":"```javascript\nfunction differenceBy(array, values, iteratee) {\n  const transformedValues = new Set(values.map(x => iteratee(x)));\n  return array.filter(x => !transformedValues.has(iteratee(x)));\n}\n```\n","src":null,"test":""},{"name":"differenceWith","manifest":{"fnSignature":"_.differenceWith(array, values?, comparator?)","lodashLink":"https://lodash.com/docs/4.17.15#differenceWith","summary":"This method is like `_.difference` except that it accepts `comparator` which is invoked to compare elements of `array` to `values`."},"description":"```javascript\nfunction differenceWith(array, values, comparator) {\n  return array.filter(x => !values.some(y => comparator(x, y)));\n}\n```\n","src":null,"test":""},{"name":"drop","manifest":{"fnSignature":"_.drop(array, n?)","lodashLink":"https://lodash.com/docs/4.17.15#drop","summary":"Creates a slice of `array` with `n` elements dropped from the beginning."},"description":"```javascript\narray.slice(n)\n```\n","src":null,"test":""},{"name":"dropRight","manifest":{"fnSignature":"_.dropRight(array, n?)","lodashLink":"https://lodash.com/docs/4.17.15#dropRight","summary":"Creates a slice of `array` with `n` elements dropped from the end."},"description":"```javascript\narray.slice(0, -n)\n```\n\nYou do have to watch out for the zero case. `_.dropRight(0)` will return the whole array, while, `array.slice(0, -0)` will return an empty array.\n","src":null,"test":""},{"name":"dropRightWhile","manifest":{"fnSignature":"_.dropRightWhile(array, predicate?)","lodashLink":"https://lodash.com/docs/4.17.15#dropRightWhile","summary":"Creates a slice of `array` excluding elements dropped from the end. Elements are dropped until `predicate` returns falsey."},"description":"```javascript\nfunction dropRightWhile(array, predicate) {\n  const index = array.findLastIndex((...args) => !predicate(...args))\n  if (index === -1) {\n    return [];\n  }\n\n  return array.slice(0, index + 1);\n}\n```","src":null,"test":""},{"name":"dropWhile","manifest":{"fnSignature":"_.dropWhile(array, predicate?)","lodashLink":"https://lodash.com/docs/4.17.15#dropWhile","summary":"Creates a slice of `array` excluding elements dropped from the beginning. Elements are dropped until `predicate` returns falsey."},"description":"```javascript\nfunction dropWhile(array, predicate) {\n  const index = array.findIndex((...args) => !predicate(...args))\n  if (index === -1) {\n    return [];\n  }\n\n  return array.slice(index);\n}\n```","src":null,"test":""},{"name":"fill","manifest":{"fnSignature":"_.fill(array, value, start?, end?)","lodashLink":"https://lodash.com/docs/4.17.15#fill","summary":"Fills elements of `array` with `value` from `start` up to, but not including, `end`."},"description":"```javascript\narray.fill(value, start, end);\n```\n\nThe `start` and `end` parameters are optional.\n","src":null,"test":""},{"name":"findIndex","manifest":{"fnSignature":"_.findIndex(array, predicate?, fromIndex?)","lodashLink":"https://lodash.com/docs/4.17.15#findIndex","summary":"This method is like `_.find` except that it returns the index of the first element `predicate` returns truthy for instead of the element itself."},"description":"```javascript\narray.findIndex(predicate);\n```\n\nIf you need to start from a particular index, a simple solution is to check which index you're at inside your predicate. In this example, we'll look for the first non-null element that exists at index 5 or greater.\n\n```javascript\narray.findIndex((value, i) => i >= 5 && value !== null);\n```\n\nIf you need to start from a particular index, and you're dealing with larger arrays, you may just need to build your own `findIndex` function from a simple for loop, in order to help with performance.\n","src":null,"test":""},{"name":"findLastIndex","manifest":{"fnSignature":"_.findLastIndex(array, predicate?, fromIndex?)","lodashLink":"https://lodash.com/docs/4.17.15#findLastIndex","summary":"This method is like `_.findIndex` except that it iterates over elements of `collection` from right to left."},"description":"```javascript\narray.findLastIndex(predicate);\n```\n\nIf you need to start from a particular index, a simple solution is to check which index you're at inside your predicate. In this example, we'll look for the first non-null element that exists at index 5 or earlier.\n\n```javascript\narray.findLastIndex((value, i) => i <= 5 && value !== null);\n```\n\nIf you need to start from a particular index, and you're dealing with larger arrays, you may just need to build your own `findLastIndex` function from a simple for loop, in order to help with performance.\n","src":null,"test":""},{"name":"flatten","manifest":{"fnSignature":"_.flatten(array)","lodashLink":"https://lodash.com/docs/4.17.15#flatten","summary":"Flattens `array` a single level deep."},"description":"```javascript\narray.flat();\n```\n","src":null,"test":""},{"name":"flattenDeep","manifest":{"fnSignature":"_.flattenDeep(array)","lodashLink":"https://lodash.com/docs/4.17.15#flattenDeep","summary":"Recursively flattens `array`."},"description":"```javascript\narray.flat(Infinity);\n```\n","src":null,"test":""},{"name":"flattenDepth","manifest":{"fnSignature":"_.flattenDepth(array, depth?)","lodashLink":"https://lodash.com/docs/4.17.15#flattenDeep","summary":"Recursively flatten `array` up to `depth` times."},"description":"```javascript\narray.flat(depth);\n```\n","src":null,"test":""},{"name":"fromPairs","manifest":{"fnSignature":"_.fromPairs(pairs)","lodashLink":"https://lodash.com/docs/4.17.15#fromPairs","summary":"The inverse of `_.toPairs`; this method returns an object composed from key-value `pairs`."},"description":"```javascript\nObject.fromEntries(pairs);\n```\n","src":null,"test":""},{"name":"head","manifest":{"fnSignature":"_.head(array)","lodashLink":"https://lodash.com/docs/4.17.15#head","summary":"Gets the first element of `array`."},"description":"```javascript\narray[0];\n```\n","src":null,"test":""},{"name":"indexOf","manifest":{"fnSignature":"_.indexOf(array, value, fromIndex?)","lodashLink":"https://lodash.com/docs/4.17.15#indexOf","summary":"Gets the index at which the first occurrence of `value` is found in `array` using `SameValueZero` for equality comparisons. If `fromIndex` is negative, it's used as the offset from the end of array."},"description":"```javascript\narray.findIndex(x => x === value);\n```\n\nIf you need to start from a particular index, a simple solution is to check which index you're at inside your predicate. In this example, we'll look for the index of the first `42` that exists at index 5 or greater.\n\n```javascript\narray.findIndex((value, i) => i >= 5 && value === 42);\n```\n\nIf you need to start from a particular index, and you're dealing with larger arrays, you may just need to build your own `findIndex` function using a simple for loop, in order to help with performance.\n\nIf you wish to perform comparisons using [the SameValueZero algorithm](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#same-value-zero_equality), similar to how Lodash does it, you can use this helper function:\n\n```javascript\nfunction sameValueZero(x, y) {\n  return x === y || (Number.isNaN(x) && Number.isNaN(y));\n}\n```\n","src":null,"test":""},{"name":"initial","manifest":{"fnSignature":"_.initial(array)","lodashLink":"https://lodash.com/docs/4.17.15#initial","summary":"Gets all but the last element of `array`."},"description":"```javascript\narray.slice(0, -1)\n```\n","src":null,"test":""},{"name":"intersection","manifest":{"fnSignature":"_.intersection(...arrays)","lodashLink":"https://lodash.com/docs/4.17.15#intersection","summary":"Creates an array of unique values that are included in all given arrays using `SameValueZero` for equality comparisons."},"description":"To take the intersection of array1 and array2, use the following:\n\n```javascript\narray1.filter(x => array2.includes(x));\n```\n\nIf you also wish to remove duplicate elements from the final result, the same way `_.intersection()` does, you can use a set, like so:\n\n```javascript\nconst resultWithDuplicates = array1.filter(x => array2.includes(x));\nconst resultWithoutDuplicates = [...new Set(resultWithDuplicates)];\n```\n\nRemember that `.includes()` has an `O(n)` lookup time. If you're dealing with larger arrays, make sure to convert the second array into a set (a set's `.has()` method has `O(1)` lookup time).\n\n```javascript\nconst set2 = new Set(array2);\nconst resultWithDuplicates = array1.filter(x => set2.has(x));\n```\n\nBoth `array.includes()` and `set.has()` use [the SameValueZero comparison algorithm](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#same-value-zero_equality) under-the-hood as well, just like Lodash's `_.intersection()`.\n\nThere is [an upcoming proposal](https://github.com/tc39/proposal-set-methods) that will introduce a native `.intersection()` method for sets.\n","src":null,"test":""},{"name":"intersectionBy","manifest":{"fnSignature":"_.intersectionBy(...arrays, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#intersectionBy","summary":"This method is like `_.intersection` except that it accepts `iteratee` which is invoked for each element of each `arrays` to generate the criterion by which they're compared."},"description":"```javascript\nfunction intersectionBy(array1, array2, iteratee = x => x) {\n  const result = [];\n  const resultTransformed = new Set();\n  const array2Transformed = new Set(array2.map(x => iteratee(x)));\n  for (const element of array1) {\n    const transformedElement = iteratee(element);\n    const isInIntersection = (\n      !resultTransformed.has(transformedElement)\n      && array2Transformed.has(transformedElement)\n    );\n\n    if (isInIntersection) {\n      result.push(element);\n      resultTransformed.add(transformedElement);\n    }\n  }\n\n  return result;\n}\n```\n\nIf you know that `array1` doesn't contain duplicate elements, or you don't care if duplicate elements from `array1` end up in the final result, then this implementation will achieve the same effect:\n\n```javascript\nfunction intersectionBy(array1, array2, iteratee = x => x) {\n  const array2Transformed = new Set(array2.map(x => iteratee(x)));\n  return array1.filter(x => array2Transformed.has(iteratee(x)));\n}\n```\n","src":null,"test":""},{"name":"intersectionWith","manifest":{"fnSignature":"_.intersectionWith(...arrays, comparator?)","lodashLink":"https://lodash.com/docs/4.17.15#intersectionWith","summary":"This method is like `_.intersection` except that it accepts `comparator` which is invoked to compare elements of `arrays`."},"description":"```javascript\nfunction intersectionWith(array1, array2, comparator) {\n  const result = [];\n  for (const element of array1) {\n    const isInIntersection = (\n      !result.some(x => comparator(x, element))\n      && array2.some(x => comparator(x, element))\n    );\n\n    if (isInIntersection) {\n      result.push(element);\n    }\n  }\n\n  return result;\n}\n```\n\nIf you know that `array1` doesn't contain duplicate elements, or you don't care if duplicate elements from `array1` end up in the final result, then this implementation will achieve the same effect:\n\n```javascript\nfunction intersectionWith(array1, array2, comparator) {\n  return array1.filter(x => array2.some(y => comparator(x, y)));\n}\n```\n","src":null,"test":""},{"name":"join","manifest":{"fnSignature":"_.join(array, separator?)","lodashLink":"https://lodash.com/docs/4.17.15#join","summary":"Converts all elements in `array` into a string separated by `separator`."},"description":"```javascript\narray.join(separator);\n```\n","src":null,"test":""},{"name":"last","manifest":{"fnSignature":"_.last(array)","lodashLink":"https://lodash.com/docs/4.17.15#last","summary":"Gets the last element of `array`."},"description":"```javascript\narray.at(-1);\n```\n","src":null,"test":""},{"name":"lastIndexOf","manifest":{"fnSignature":"_.lastIndexOf(array, value, fromIndex?)","lodashLink":"https://lodash.com/docs/4.17.15#lastIndexOf","summary":"This method is like `_.indexOf` except that it iterates over elements of `array` from right to left."},"description":"```javascript\narray.findLastIndex(x => x === value);\n```\n\nIf you need to start from a particular index, a simple solution is to check which index you're at inside your predicate. In this example, we'll look for the index of the last `42` that exists at index 5 or lower.\n\n```javascript\narray.findLastIndex((value, i) => i <= 5 && value === 42);\n```\n\nIf you need to start from a particular index, and you're dealing with larger arrays, you may just need to build your own `findLastIndex` function using a simple for loop, in order to help with performance.\n\nIf you wish to perform comparisons using [the SameValueZero algorithm](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#same-value-zero_equality), similar to how Lodash does it, you can use this helper function:\n\n```javascript\nfunction sameValueZero(x, y) {\n  return x === y || (Number.isNaN(x) && Number.isNaN(y));\n}\n```\n","src":null,"test":""},{"name":"nth","manifest":{"fnSignature":"_.nth(array, n?)","lodashLink":"https://lodash.com/docs/4.17.15#nth","summary":"Gets the element at index `n` of `array`. If `n` is negative, the nth element from the end is returned."},"description":"```javascript\narray[n];\n```\n\nOr, if you need support for negative indices:\n\n```javascript\narray.at(n);\n```\n","src":null,"test":""},{"name":"pull","manifest":{"fnSignature":"_.pull(array, ...values)","lodashLink":"https://lodash.com/docs/4.17.15#pull","summary":"Removes all given values from `array` using `SameValueZero` for equality comparisons. Note: Unlike `_.without`, this method mutates `array`."},"description":"In general, it's recommended to avoid mutating the original array, but if you must, the following `filterInPlace()` helper can be used to achieve the desired result in `O(n)` time.\n\n```javascript\nfunction filterInPlace(array, predicate) {\n  let destIndex = 0;\n  for (let srcIndex = 0; srcIndex < array.length; ++srcIndex) {\n    if (!predicate(array[srcIndex], srcIndex)) {\n      continue;\n    }\n    array[destIndex] = array[srcIndex]\n    destIndex++;\n  }\n\n  array.splice(destIndex, array.length - destIndex);\n}\n\n// Pull everything out from `array` that equals `targetValue`.\nconst result = filterInPlace(array, x => x === targetValue);\n```\n\nIf you wish to perform comparisons using [the SameValueZero algorithm](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#same-value-zero_equality), similar to how Lodash does it, you can use this helper function:\n\n```javascript\nfunction sameValueZero(x, y) {\n  return x === y || (Number.isNaN(x) && Number.isNaN(y));\n}\n```\n\nSee the `_.pullAll()` entry if you have multiple items you wish to pull at once.\n","src":null,"test":""},{"name":"pullAll","manifest":{"fnSignature":"_.pullAll(array, values)","lodashLink":"https://lodash.com/docs/4.17.15#pullAll","summary":"This method is like `_.pull` except that it accepts an array of values to remove."},"description":"In general, it's recommended to avoid mutating the original array, but if you must, the following `filterInPlace()` helper can be used to achieve the desired result in `O(n)` time.\n\n```javascript\nfunction filterInPlace(array, predicate) {\n  let destIndex = 0;\n  for (let srcIndex = 0; srcIndex < array.length; ++srcIndex) {\n    if (!predicate(array[srcIndex], srcIndex)) {\n      continue;\n    }\n    array[destIndex] = array[srcIndex]\n    destIndex++;\n  }\n\n  array.splice(destIndex, array.length - destIndex);\n}\n\n// Pull everything in the `values` array from `array`.\nconst result = filterInPlace(array, x => values.include(x));\n```\n\nRemember that the `values.includes()` used at the end also has an `O(n)` lookup time. If you're dealing with a larger `values` array, make sure to convert it into a set first (a set's `.has()` method has `O(1)` lookup time).\n\nBoth `array.includes()` and `set.has()` use [the SameValueZero comparison algorithm](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#same-value-zero_equality) under-the-hood as well, just like Lodash's `_.pull()`.\n","src":null,"test":""},{"name":"pullAllBy","manifest":{"fnSignature":"_.pullAllBy(array, values, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#pullAllBy","summary":"This method is like `_.pullAll` except that it accepts `iteratee` which is invoked for each element of `array` and `values` to generate the criterion by which they're compared."},"description":"In general, it's recommended to avoid mutating the original array, but if you must, the following `filterInPlace()` helper can be used to achieve the desired result in `O(n)` time.\n\n```javascript\nfunction filterInPlace(array, predicate) {\n  let destIndex = 0;\n  for (let srcIndex = 0; srcIndex < array.length; ++srcIndex) {\n    if (!predicate(array[srcIndex], srcIndex)) {\n      continue;\n    }\n    array[destIndex] = array[srcIndex]\n    destIndex++;\n  }\n\n  array.splice(destIndex, array.length - destIndex);\n}\n\nfunction pullAllBy(array, values, iteratee) {\n  const transformedValues = new Set(values.map(x => iteratee(x)));\n  filterInPlace(array, x => !transformedValues.has(iteratee(x)));\n}\n```\n","src":null,"test":""},{"name":"pullAllWith","manifest":{"fnSignature":"_.pullAllWith(array, values, comparator?)","lodashLink":"https://lodash.com/docs/4.17.15#pullAllWith","summary":"This method is like `_.pullAll` except that it accepts `comparator` which is invoked to compare elements of `array` to `values`."},"description":"In general, it's recommended to avoid mutating the original array, but if you must, the following `filterInPlace()` helper can be used to achieve the desired result.\n\n```javascript\nfunction filterInPlace(array, predicate) {\n  let destIndex = 0;\n  for (let srcIndex = 0; srcIndex < array.length; ++srcIndex) {\n    if (!predicate(array[srcIndex], srcIndex)) {\n      continue;\n    }\n    array[destIndex] = array[srcIndex]\n    destIndex++;\n  }\n\n  array.splice(destIndex, array.length - destIndex);\n}\n\nfunction pullAllWith(array, values, comparator) {\n  filterInPlace(array, x => !values.some(y => comparator(x, y)));\n}\n```\n","src":null,"test":""},{"name":"pullAt","manifest":{"fnSignature":"_.pullAt(array, indexes?)","lodashLink":"https://lodash.com/docs/4.17.15#pullAt","summary":"Removes elements from `array` corresponding to `indexes` and returns an array of removed elements."},"description":"In general, it's recommended to avoid mutating the original array, but if you must, the following `filterInPlace()` helper can be used to achieve the desired result in `O(n)` time.\n\n```javascript\nfunction filterInPlace(array, predicate) {\n  let destIndex = 0;\n  for (let srcIndex = 0; srcIndex < array.length; ++srcIndex) {\n    if (!predicate(array[srcIndex], srcIndex)) {\n      continue;\n    }\n    array[destIndex] = array[srcIndex]\n    destIndex++;\n  }\n\n  array.splice(destIndex, array.length - destIndex);\n}\n\nfunction pullAt(array, indexes_) {\n  const pulled = indexes_.map(i => array[i]);\n  const indexes = new Set(indexes_);\n  filterInPlace(array, (_, i) => !indexes.has(i));\n  return pulled;\n}\n```\n","src":null,"test":""},{"name":"remove","manifest":{"fnSignature":"_.remove(array, predicate?)","lodashLink":"https://lodash.com/docs/4.17.15#remove","summary":"Removes all elements from `array` that `predicate` returns truthy for and returns an array of the removed elements."},"description":"In general, it's recommended to avoid mutating the original array, but if you must, the following implementation can be used to achieve the desired result in `O(n)` time.\n\n```javascript\nfunction remove(array, predicate) {\n  let destIndex = 0;\n  for (let srcIndex = 0; srcIndex < array.length; ++srcIndex) {\n    if (!predicate(array[srcIndex], srcIndex)) {\n      continue;\n    }\n    array[destIndex] = array[srcIndex]\n    destIndex++;\n  }\n\n  array.splice(destIndex, array.length - destIndex);\n}\n```\n","src":null,"test":""},{"name":"reverse","manifest":{"fnSignature":"_.reverse(array)","lodashLink":"https://lodash.com/docs/4.17.15#reverse","summary":"Reverses `array` so that the first element becomes the last, the second element becomes the second to last, and so on."},"description":"```javascript\narray.reverse();\n```\n","src":null,"test":""},{"name":"slice","manifest":{"fnSignature":"_.slice(array, start?, end?)","lodashLink":"https://lodash.com/docs/4.17.15#slice","summary":"Creates a slice of `array` from `start` up to, but not including, `end`."},"description":"```javascript\narray.slice(start, end);\n```\n\nOne benefit of Lodash's implementation of `.slice()`, is that it'll always return a dense array (as opposed to a [sparse one](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Indexed_collections#sparse_arrays)). The same behavior can be achieved in vanilla JavaScript by simply spreading the array into another one.\n\n```javascript\nconst sparseArray = [2,,3,,4]; // [2, <empty>, 3, <empty>, 4]\nconst denseArray = [...sparseArray]; // [2, undefined, 3, undefined, 4]\nconsole.log(denseArray.slice(1, 3)); // [undefined, 3]\n```\n\nNote, however, that Lodash is providing this behavior, mostly because it makes their `.slice()` implementation more consistent with how newer JavaScript array methods treat sparse arrays - by pretending the holes are the same as `undefined` values. In practice, such a feature shouldn't make a difference in your codebase, as it's generally considered bad practice to create or pass around sparse arrays. If you're a library developer who may be receiving arbitrary user input, simply treat arguments that could potentially be sparse arrays the same way you would treat any other kind of bad input the end-user gives you. If you don't do any data validation, then don't worry about it - a sparse array would result in undefined behavior, the same way any other bad input would. If you do up-front data validation, you can choose to add the detection of sparse arrays as an additional up-front check.\n","src":null,"test":""},{"name":"sortedIndex","manifest":{"fnSignature":"_.sortedIndex(array, value)","lodashLink":"https://lodash.com/docs/4.17.15#sortedIndex","summary":"Uses a binary search to determine the lowest index at which `value` should be inserted into `array` in order to maintain its sort order."},"description":"```javascript\nfunction sortedIndex(array, value, _range) {\n  const [low, high] = _range ?? [0, array.length];\n  if (low === high) {\n    return low;\n  }\n\n  const midPoint = low + Math.floor((high - low) / 2);\n  const newRange = value <= array[midPoint]\n    ? [low, midPoint]\n    : [midPoint + 1, high];\n\n  return sortedIndex(array, value, newRange);\n}\n```\n","src":null,"test":""},{"name":"sortedIndexBy","manifest":{"fnSignature":"_.sortedIndexBy(array, value, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#sortedIndexBy","summary":"This method is like `_.sortedIndex` except that it accepts `iteratee` which is invoked for `value` and each element of `array` to compute their sort ranking."},"description":"```javascript\nfunction sortedIndexBy(array, value, iteratee, _recurseOpts) {\n  _recurseOpts ??= {\n    range: [0, array.length],\n    transformedValue: iteratee(value),\n  };\n\n  const transformedValue = _recurseOpts.transformedValue;\n  const [low, high] = _recurseOpts.range;\n  if (low === high) {\n    return low;\n  }\n\n  const midPoint = low + Math.floor((high - low) / 2);\n  const newRange = transformedValue <= iteratee(array[midPoint])\n    ? [low, midPoint]\n    : [midPoint + 1, high];\n\n  return sortedIndexBy(array, value, iteratee, { transformedValue, range: newRange });\n}\n```\n","src":null,"test":""},{"name":"sortedIndexOf","manifest":{"fnSignature":"_.sortedIndexOf(array, value)","lodashLink":"https://lodash.com/docs/4.17.15#sortedIndexOf","summary":"This method is like `_.indexOf` except that it performs a binary search on a sorted `array`."},"description":"We will use a vanilla JavaScript implementation of `_.sortedIndex()` to help define `sortedIndexOf()`.\n\n```javascript\nfunction sortedIndex(array, value, _range) {\n  const [low, high] = _range ?? [0, array.length];\n  if (low === high) {\n    return low;\n  }\n\n  const midPoint = low + Math.floor((high - low) / 2);\n  const newRange = value <= array[midPoint]\n    ? [low, midPoint]\n    : [midPoint + 1, high];\n\n  return sortedIndex(array, value, newRange);\n}\n\nfunction sortedIndexOf(array, value) {\n  const index = sortedIndex(array, value);\n  return array[index] === value ? index : -1;\n}\n```","src":null,"test":""},{"name":"sortedLastIndex","manifest":{"fnSignature":"_.sortedLastIndex(array, value)","lodashLink":"https://lodash.com/docs/4.17.15#sortedLastIndex","summary":"This method is like `_.sortedIndex` except that it returns the highest index at which `value` should be inserted into `array` in order to maintain its sort order."},"description":"```javascript\nfunction sortedLastIndex(array, value, _range) {\n  const [low, high] = _range ?? [0, array.length];\n  if (low === high) {\n    return low;\n  }\n\n  const midPoint = low + Math.floor((high - low) / 2);\n  const newRange = value < array[midPoint]\n    ? [low, midPoint]\n    : [midPoint + 1, high];\n\n  return sortedLastIndex(array, value, newRange);\n}\n```\n","src":null,"test":""},{"name":"sortedLastIndexBy","manifest":{"fnSignature":"_.sortedLastIndexBy(array, value, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#sortedLastIndexBy","summary":"This method is like `_.sortedLastIndex` except that it accepts `iteratee` which is invoked for value and each element of array to compute their sort ranking."},"description":"```javascript\nfunction sortedLastIndexBy(array, value, iteratee, _recurseOpts) {\n  _recurseOpts ??= {\n    range: [0, array.length],\n    transformedValue: iteratee(value),\n  };\n\n  const transformedValue = _recurseOpts.transformedValue;\n  const [low, high] = _recurseOpts.range;\n  if (low === high) {\n    return low;\n  }\n\n  const midPoint = low + Math.floor((high - low) / 2);\n  const newRange = transformedValue < iteratee(array[midPoint])\n    ? [low, midPoint]\n    : [midPoint + 1, high];\n\n  return sortedLastIndexBy(array, value, iteratee, { transformedValue, range: newRange });\n}\n```\n","src":null,"test":""},{"name":"sortedLastIndexOf","manifest":{"fnSignature":"_.sortedLastIndexOf(array, value)","lodashLink":"https://lodash.com/docs/4.17.15#sortedLastIndexOf","summary":"This method is like `_.lastIndexOf` except that it performs a binary search on a sorted `array`."},"description":"We will use a vanilla JavaScript implementation of `_.sortedLastIndex()` to help define `sortedLastIndexOf()`.\n\n```javascript\nfunction sortedLastIndex(array, value, _range) {\n  const [low, high] = _range ?? [0, array.length];\n  if (low === high) {\n    return low;\n  }\n\n  const midPoint = low + Math.floor((high - low) / 2);\n  const newRange = value < array[midPoint]\n    ? [low, midPoint]\n    : [midPoint + 1, high];\n\n  return sortedLastIndex(array, value, newRange);\n}\n\nfunction sortedLastIndexOf(array, value) {\n  const index = sortedLastIndex(array, value) - 1;\n  return index > -1 && array[index] === value ? index : -1;\n}\n```","src":null,"test":""},{"name":"sortedUniq","manifest":{"fnSignature":"_.sortedUniq(array)","lodashLink":"https://lodash.com/docs/4.17.15#sortedUniq","summary":"This method is like `_.uniq` except that it's designed and optimized for sorted arrays."},"description":"```javascript\nfunction sortedUniq(array) {\n  if (array.length === 0) {\n    return [];\n  }\n\n  const result = [array[0]];\n  for (const value of array) {\n    if (result[result.length - 1] !== value) {\n      result.push(value);\n    }\n  }\n\n  return result;\n}\n```\n\n[Some basic benchmarks](https://gist.github.com/theScottyJam/8424183e49f4555b60752b21f1076129) shows that performance improves as the number of repeated items increase. If you're not dealing with large arrays, or arrays with many repeated items, then using the simpler `[...new Set(array)]` solution should be sufficient.\n","src":null,"test":""},{"name":"sortedUniqBy","manifest":{"fnSignature":"_.sortedUniqBy(array, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#sortedUniqBy","summary":"This method is like `_.uniqBy` except that it's designed and optimized for sorted arrays."},"description":"```javascript\nfunction sortedUniqBy(array, iteratee) {\n  if (array.length === 0) {\n    return [];\n  }\n\n  let lastTransformedValue = iteratee(array[0]);\n  const result = [array[0]];\n  for (let i = 0; i < array.length; ++i) {\n    const transformedValue = iteratee(array[i]);\n    if (lastTransformedValue !== transformedValue) {\n      result.push(array[i]);\n      lastTransformedValue = transformedValue;\n    }\n  }\n\n  return result;\n}\n```\n","src":null,"test":""},{"name":"tail","manifest":{"fnSignature":"_.tail(array)","lodashLink":"https://lodash.com/docs/4.17.15#tail","summary":"Gets all but the first element of `array`."},"description":"```javascript\narray.slice(1);\n```\n","src":null,"test":""},{"name":"take","manifest":{"fnSignature":"_.take(array, n?)","lodashLink":"https://lodash.com/docs/4.17.15#take","summary":"Creates a slice of `array` with `n` elements taken from the beginning."},"description":"```javascript\narray.slice(0, n);\n```\n","src":null,"test":""},{"name":"takeRight","manifest":{"fnSignature":"_.takeRight(array, n?)","lodashLink":"https://lodash.com/docs/4.17.15#takeRight","summary":"Creates a slice of `array` with `n` elements taken from the end."},"description":"```javascript\narray.slice(-n);\n```\n\nYou do have to watch out for the zero case. `_.takeRight(0)` will return an empty array, while, `array.slice(-0)` will return the whole array.\n","src":null,"test":""},{"name":"takeRightWhile","manifest":{"fnSignature":"_.takeRightWhile(array, predicate?)","lodashLink":"https://lodash.com/docs/4.17.15#takeRightWhile","summary":"Creates a slice of `array` with elements taken from the end. Elements are taken until `predicate` returns falsey."},"description":"```javascript\nfunction takeRightWhile(array, predicate) {\n  const index = array.findLastIndex((...args) => !predicate(...args))\n  if (index === -1) {\n    return array;\n  }\n\n  return array.slice(index + 1);\n}\n```\n","src":null,"test":""},{"name":"takeWhile","manifest":{"fnSignature":"_.takeWhile(array, predicate?)","lodashLink":"https://lodash.com/docs/4.17.15#takeWhile","summary":"Creates a slice of `array` with elements taken from the beginning. Elements are taken until `predicate` returns falsey."},"description":"```javascript\nfunction takeWhile(array, predicate) {\n  const index = array.findIndex((...args) => !predicate(...args))\n  if (index === -1) {\n    return array;\n  }\n\n  return array.slice(0, index);\n}\n```\n","src":null,"test":""},{"name":"union","manifest":{"fnSignature":"_.union(...arrays)","lodashLink":"https://lodash.com/docs/4.17.15#union","summary":"Creates an array of unique values, in order, from all given arrays using `SameValueZero` for equality comparisons."},"description":"```javascript\n[...new Set([...array1, ...array2])];\n```\n\nSets internally use [the SameValueZero comparison algorithm](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#same-value-zero_equality) under-the-hood, just like Lodash's `_.union()`.\n\nThere is [an upcoming proposal](https://github.com/tc39/proposal-set-methods) that will introduce a native `.union()` method for sets.\n","src":null,"test":""},{"name":"unionBy","manifest":{"fnSignature":"_.unionBy(...arrays, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#unionBy","summary":"This method is like `_.union` except that it accepts `iteratee` which is invoked for each element of each `arrays` to generate the criterion by which uniqueness is computed."},"description":"We will use a vanilla JavaScript implementation of `_.uniqBy()` to solve this problem.\n\n```javascript\nfunction uniqBy(array, iteratee) {\n  const transformedResults = new Set();\n  const result = [];\n  for (const element of array) {\n    const transformedElement = iteratee(element);\n    if (!transformedResults.has(transformedElement)) {\n      transformedResults.add(transformedElement);\n      result.push(element);\n    }\n  }\n\n  return result;\n}\n\n// Merge the given arrays, then filter out duplicates.\n// This end-effect will be the union of these two arrays,\n// using `iteratee` to decide equivalence.\nuniqBy([...array1, ...array2], iteratee);\n```\n","src":null,"test":""},{"name":"unionWith","manifest":{"fnSignature":"_.unionWith(array, comparator?)","lodashLink":"https://lodash.com/docs/4.17.15#unionWith","summary":"This method is like `_.union` except that it accepts `comparator` which is invoked to compare elements of `arrays`."},"description":"We will use a vanilla JavaScript implementation of `_.uniqWith()` to solve this problem.\n\n```javascript\nfunction uniqWith(array, comparator) {\n  const result = [];\n  for (const element of array) {\n    if (result.every(x => !comparator(x, element))) {\n      result.push(element);\n    }\n  }\n\n  return result;\n}\n\n// Merge the given arrays, then filter out duplicates.\n// This end-effect will be the union of these two arrays,\n// using `comparator` to decide equivalence.\nuniqWith([...array1, ...array2], comparator);\n```\n","src":null,"test":""},{"name":"uniq","manifest":{"fnSignature":"_.uniq(array)","lodashLink":"https://lodash.com/docs/4.17.15#uniq","summary":"Creates a duplicate-free version of an array, using `SameValueZero` for equality comparisons."},"description":"```javascript\n[...new Set(array)];\n```\n\nSets internally use [the SameValueZero comparison algorithm](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#same-value-zero_equality) under-the-hood, just like Lodash's `_.uniq()`.\n","src":null,"test":""},{"name":"uniqBy","manifest":{"fnSignature":"_.uniqBy(array, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#uniqBy","summary":"This method is like `_.uniq` except that it accepts `iteratee` which is invoked for each element in array to generate the criterion by which uniqueness is computed."},"description":"```javascript\nfunction uniqBy(array, iteratee) {\n  const transformedResults = new Set();\n  const result = [];\n  for (const element of array) {\n    const transformedElement = iteratee(element);\n    if (!transformedResults.has(transformedElement)) {\n      transformedResults.add(transformedElement);\n      result.push(element);\n    }\n  }\n\n  return result;\n}\n```\n","src":null,"test":""},{"name":"unzip","manifest":{"fnSignature":"_.unzip(array)","lodashLink":"https://lodash.com/docs/4.17.15#unzip","summary":"This method is like `_.zip` except that it accepts an array of grouped elements and creates an array regrouping the elements to their pre-zip configuration."},"description":"`_.zip()` is actually the inverse of itself, meaning you can use it to unzip the result of `_.zip()`, like this:\n\n```javascript\nconst original = [[1, 2, 3], ['A', 'B', 'C']]\nconst zipped = _.zip(...original); // [[1, 'A'], [2, 'B'], [3, 'C']]\nconst unzipped = _.zip(...zipped); // [[1, 2, 3], ['A', 'B', 'C']]\n```\n\nThe only difference between `_.zip()` and `_.unzip()` is how it accepts parameters.\n\n```javascript\n// With _.zip(), arrays are passed in as separate parameters\n_.zip([1, 2], ['A', 'B']);     // [[1, 'A'], [2, 'B']]\n// With _.unzip(), arrays are placed inside a single larger array.\n_.unzip([[1, 2], ['A', 'B']]); // [[1, 'A'], [2, 'B']]\n```\n\nSo, to implement an unzip function, all you really need is an implementation for `zip()`.\n\n```javascript\nfunction zip(...arrays) {\n  if (arrays.length === 0) {\n    return [];\n  }\n\n  const minLength = Math.min(...arrays.map(arr => arr.length));\n  const result = [];\n  for (let i = 0; i < minLength; ++i) {\n    result.push(arrays.map(arr => arr[i]));\n  }\n\n  return result;\n}\n```\n\nIf you want a Lodash-style unzip function, here's how to implement it:\n\n```javascript\nfunction unzip(arrays) {\n  return zip(...arrays);\n}\n```\n","src":null,"test":""},{"name":"unzipWith","manifest":{"fnSignature":"_.unzipWith(array, iteratee)","lodashLink":"https://lodash.com/docs/4.17.15#unzipWith","summary":"This method is like `_.unzip` except that it accepts `iteratee` to specify how regrouped values should be combined."},"description":"The only difference between `_.zipWith()` and `_.unzipWith()` is how it accepts parameters.\n\n```javascript\n// With _.zipWith(), arrays are passed in as separate parameters\n_.zipWith([10, 20], [1, 2], (a, b) => a + b);     // [11, 22]\n// With _.unzipWith(), arrays are placed inside a single larger array.\n_.unzipWith([[10, 20], [1, 2]], (a, b) => a + b); // [11, 22]\n```\n\n!!!!\n\nSo, to implement an unzipWith function, all you really need is an implementation for `zipWith()`.\n\n```javascript\nfunction zipWith(...args) {\n  const arrays = args.slice(0, -1);\n  const iteratee = args.at(-1);\n  if (arrays.length === 0) {\n    return [];\n  }\n\n  const minLength = Math.min(...arrays.map(arr => arr.length));\n  const result = [];\n  for (let i = 0; i < minLength; ++i) {\n    result.push(iteratee(...arrays.map(arr => arr[i])));\n  }\n\n  return result;\n}\n```\n\nIf you want a Lodash-style unzipWith function, here's how to implement it:\n\n```javascript\nfunction unzipWith(arrays, iteratee) {\n  return zip(arrays, iteratee);\n}\n```\n","src":null,"test":""},{"name":"without","manifest":{"fnSignature":"_.without(array, ...values)","lodashLink":"https://lodash.com/docs/4.17.15#without","summary":"Creates an array excluding all given values using `SameValueZero` for equality comparisons."},"description":"```javascript\narray.filter(x => x !== value);\n```\n\nIf you wish to filter out multiple values, look at the vanilla JavaScript version of `_.difference()`. Both `_.difference()` and _.without()` achieve the same effect, but with slightly different function signatures.\n\nIf you wish to perform comparisons using [the SameValueZero algorithm](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#same-value-zero_equality), similar to how Lodash does it, you can use this helper function:\n\n```javascript\nfunction sameValueZero(x, y) {\n  return x === y || (Number.isNaN(x) && Number.isNaN(y));\n}\n```\n","src":null,"test":""},{"name":"xor","manifest":{"fnSignature":"_.xor(...arrays)","lodashLink":"https://lodash.com/docs/4.17.15#xor","summary":"Creates an array of unique values that is the symmetric difference of the given arrays."},"description":"```javascript\nfunction xor(array1, array2) {\n  const set1 = new Set(array1);\n  const set2 = new Set(array2);\n  return [\n    ...array1.filter(x => !set2.has(x)),\n    ...array2.filter(x => !set1.has(x)),\n  ];\n}\n```\n","src":null,"test":""},{"name":"xorBy","manifest":{"fnSignature":"_.xorBy(...arrays, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#xorBy","summary":"This method is like `_.xor` except that it accepts `iteratee` which is invoked for each element of each `arrays` to generate the criterion by which by which they're compared."},"description":"```javascript\nfunction xorBy(array1, array2, predicate) {\n  const set1 = new Set(array1.map(x => predicate(x)));\n  const set2 = new Set(array2.map(x => predicate(x)));\n  return [\n    ...array1.filter(x => !set2.has(predicate(x))),\n    ...array2.filter(x => !set1.has(predicate(x))),\n  ];\n}\n```\n","src":null,"test":""},{"name":"xorWith","manifest":{"fnSignature":"_.xorWith(...arrays, comparator?)","lodashLink":"https://lodash.com/docs/4.17.15#xorWith","summary":"This method is like `_.xor` except that it accepts `comparator` which is invoked to compare elements of arrays."},"description":"```javascript\nfunction xorWith(array1, array2, comparator) {\n  return [\n    ...array1.filter(x => !array2.some(y => comparator(x, y))),\n    ...array2.filter(x => !array1.some(y => comparator(x, y))),\n  ];\n}\n```\n","src":null,"test":""},{"name":"zip","manifest":{"fnSignature":"_.zip(...arrays)","lodashLink":"https://lodash.com/docs/4.17.15#zip","summary":"Creates an array of grouped elements, the first of which contains the first elements of the given arrays, the second of which contains the second elements of the given arrays, and so on."},"description":"```javascript\nfunction zip(...arrays) {\n  if (arrays.length === 0) {\n    return [];\n  }\n\n  const minLength = Math.min(...arrays.map(arr => arr.length));\n  const result = [];\n  for (let i = 0; i < minLength; ++i) {\n    result.push(arrays.map(arr => arr[i]));\n  }\n\n  return result;\n}\n```\n","src":null,"test":""},{"name":"zipObject","manifest":{"fnSignature":"_.zipObject(props?, values?)","lodashLink":"https://lodash.com/docs/4.17.15#zipObject","summary":"This method is like `_.fromPairs` except that it accepts two arrays, one of property identifiers and one of corresponding values."},"description":"We will use a vanilla JavaScript implementation of `_.zip()` to solve this problem.\n\n```javascript\nfunction zip(...arrays) {\n  if (arrays.length === 0) {\n    return [];\n  }\n\n  const minLength = Math.min(...arrays.map(arr => arr.length));\n  const result = [];\n  for (let i = 0; i < minLength; ++i) {\n    result.push(arrays.map(arr => arr[i]));\n  }\n\n  return result;\n}\n\n// First zips the keys and values,\n// then build an object from the zipped entries.\nObject.fromEntries(zip(props, values));\n```\n","src":null,"test":""},{"name":"zipObjectDeep","manifest":{"fnSignature":"_.zipObjectDeep(props?, values?)","lodashLink":"https://lodash.com/docs/4.17.15#zipObjectDeep","summary":"This method is like `_.zipObject` except that it supports property paths."},"description":"It's recommended to avoid this function. Building objects via dynamic string paths may (or may not) be indicative of a deeper issue with how the problem is being approached. But, if you really do need support for this sort of thing, it can be done, with the help of the vanilla JavaScript implementation of `_.set()` and `_.zip()`.\n\n```javascript\nfunction set(object, path, value) {\n  if (typeof path === 'string') {\n    const isQuoted = str => str[0] === '\"' && str.at(-1) === '\"';\n    path = path.split(/[.\\[\\]]+/)\n      .filter(x => x)\n      .map(x => !isNaN(Number(x)) ? Number(x) : x)\n      .map(x => typeof x === 'string' && isQuoted(x) ? x.slice(1, -1) : x);\n  }\n\n  if (path.length === 0) {\n    throw new Error('The path must have at least one entry in it');\n  }\n\n  const [head, ...tail] = path;\n\n  if (tail.length === 0) {\n    object[head] = value;\n    return;\n  }\n\n  if (!(head in object)) {\n    object[head] = typeof tail[0] === 'number' ? [] : {};\n  }\n\n  return set(object[head], tail, value)\n}\n\nfunction zip(...arrays) {\n  if (arrays.length === 0) {\n    return [];\n  }\n\n  const minLength = Math.min(...arrays.map(arr => arr.length));\n  const result = [];\n  for (let i = 0; i < minLength; ++i) {\n    result.push(arrays.map(arr => arr[i]));\n  }\n\n  return result;\n}\n\nfunction zipObjectDeep(props, values) {\n  const resultObj = {};\n  for (const [path, value] of zip(props, values)) {\n    set(resultObj, path, value);\n  }\n\n  return resultObj;\n}\n```\n\nNote that the support for string paths in the above `zipObjectDeep()` implementation isn't very robust. It'll take invalid-looking input, such as `\"prop1.[prop2\"`, ignore the invalid parts, and attempt to work with it anyways. Lodash's `_.zipObjectDeep()` isn't all that different in this regard.\n","src":null,"test":""},{"name":"zipWith","manifest":{"fnSignature":"_.zipWith(...arrays, iteratee)","lodashLink":"https://lodash.com/docs/4.17.15#zipWith","summary":"This method is like `_.zip` except that it accepts `iteratee` to specify how grouped values should be combined."},"description":"```javascript\nfunction zipWith(...args) {\n  const arrays = args.slice(0, -1);\n  const iteratee = args.at(-1);\n  if (arrays.length === 0) {\n    return [];\n  }\n\n  const minLength = Math.min(...arrays.map(arr => arr.length));\n  const result = [];\n  for (let i = 0; i < minLength; ++i) {\n    result.push(iteratee(...arrays.map(arr => arr[i])));\n  }\n\n  return result;\n}\n```\n","src":null,"test":""}]},{"categoryHeading":"Date","entries":[{"name":"now","manifest":{"fnSignature":"_.now()","lodashLink":"https://lodash.com/docs/4.17.15#now","summary":"Gets the timestamp of the number of milliseconds that have elapsed since the Unix epoch."},"description":"```javascript\nDate.now();\n```\n","src":null,"test":""}]},{"categoryHeading":"Math","entries":[{"name":"add","manifest":{"fnSignature":"_.add(augend, addend)","lodashLink":"https://lodash.com/docs/4.17.15#add","summary":"Adds two numbers."},"description":"```javascript\naugend + addend;\n```\n\nOne reason `_.add()` exists, is because it's a ready-made function, that can easily be passed into other functions, like this:\n\n```javascript\n> _.reduce([2, 3, 4], _.add);\n9\n```\n\nWhen Lodash was first born, the only alternative at the time would be to create an entire function, using the `function` keyword.\n\n```javascript\n_.reduce([2, 3, 4], function (a, b) {\n  return a + b;\n});\n```\n\nSince then, ES6 came out with arrow functions, allowing you to define these sorts of functions in a much more concise way.\n\n```javascript\n_.reduce([2, 3, 4], (a, b) => a + b);\n```\n","src":null,"test":""},{"name":"ceil","manifest":{"fnSignature":"_.ceil(number, precision?)","lodashLink":"https://lodash.com/docs/4.17.15#ceil","summary":"Computes `number` rounded up to `precision`."},"description":"If you don't need to use the optional precision argument, then you can simply use the following:\n\n```javascript\nMath.ceil(number);\n```\n\nOtherwise:\n\n```javascript\nfunction ceil(number, precision=0) {\n  const factor = 10**precision;\n  return Math.ceil(number * factor) / factor;\n}\n```","src":null,"test":""},{"name":"divide","manifest":{"fnSignature":"_.divide(dividend, divisor)","lodashLink":"https://lodash.com/docs/4.17.15#divide","summary":"Divide two numbers."},"description":"```javascript\naugend / addend;\n```\n\nOne reason `_.divide()` exists, is because it's a ready-made function, that can easily be passed into other functions, like this:\n\n```javascript\n> _.reduce([100, 2, 5], _.divide);\n10\n```\n\nWhen Lodash was first born, the only alternative at the time would be to create an entire function, using the `function` keyword.\n\n```javascript\n_.reduce([100, 2, 5], function (a, b) {\n  return a / b;\n});\n```\n\nSince then, ES6 came out with arrow functions, allowing you to define these sorts of functions in a much more concise way.\n\n```javascript\n_.reduce([100, 2, 5], (a, b) => a / b);\n```\n","src":null,"test":""},{"name":"floor","manifest":{"fnSignature":"_.floor(number, precision?)","lodashLink":"https://lodash.com/docs/4.17.15#floor","summary":"Computes `number` rounded down to `precision`."},"description":"If you don't need to use the optional precision argument, then you can simply use the following:\n\n```javascript\nMath.floor(number);\n```\n\nOtherwise:\n\n```javascript\nfunction floor(number, precision=0) {\n  const factor = 10**precision;\n  return Math.floor(number * factor) / factor;\n}\n```","src":null,"test":""},{"name":"max","manifest":{"fnSignature":"_.max(array)","lodashLink":"https://lodash.com/docs/4.17.15#max","summary":"Computes the maximum value of array. If array is empty or falsey, undefined is returned."},"description":"```javascript\nMath.max(...array);\n```\n\nThere's a couple of very minor differences in behavior between Lodash's `_.max()`, and JavaScript's native `Math.max()` (apart from the fact that you have to spread your array into JavaScript's version).\n\n1. In Lodash's version, if you provide a falsey value, `undefined` will be returned. In JavaScript, if you try to spread a falsey value into `Math.max()`, you'll get a runtime error, because falsey values aren't iterable. In practice, this difference shouldn't matter much - you should know the types of values you're trying to use, and if you suspect that it might be falsey, just check for that before calling `Math.max()`, instead of checking if the result is undefined after calling `_.max()`.\n\n2. In Lodash's version, if you provide an empty array, `undefined` is returned. In JavaScript, if you spread an empty array, or you provide no arguments, `-Infinity` is returned. JavaScript's `-Infinity`, while, at first, may sound odd, can actually be a useful return value. It allows you to cleanly write many algorithms capable of operating on empty arrays, without having to explicitly check if the array is empty. Not everyone likes to write algorithms this way, but `Math.max()` gives you the option when it's wanted.","src":null,"test":""},{"name":"maxBy","manifest":{"fnSignature":"_.maxBy(array, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#maxBy","summary":"This method is like `_.max` except that it accepts `iteratee` which is invoked for each element in `array` to generate the criterion by which the value is ranked."},"description":"```javascript\nfunction maxBy(array, iteratee) {\n  if (array.length === 0) {\n    return undefined;\n  }\n\n  return array\n    .map(value => ({ value, score: iteratee(value) }))\n    .reduce((best, cur) => cur.score > best.score ? cur : best)\n    .value;\n}\n```\n","src":null,"test":""},{"name":"mean","manifest":{"fnSignature":"_.mean(array)","lodashLink":"https://lodash.com/docs/4.17.15#mean","summary":"Computes the mean of the values in array."},"description":"```javascript\nfunction mean(array) {\n  return array.reduce((a, b) => a + b) / array.length;\n}\n```\n","src":null,"test":""},{"name":"meanBy","manifest":{"fnSignature":"_.meanBy(array, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#meanBy","summary":"This method is like `_.mean` except that it accepts `iteratee` which is invoked for each element in `array` to generate the value to be averaged."},"description":"We will use a vanilla JavaScript implementation of `_.mean()` to solve this problem.\n\n```javascript\nfunction mean(array) {\n  return array.reduce((a, b) => a + b) / array.length;\n}\n\n// Uses `iteratee` on each element of the array, to convert them to\n// new values, before taking the mean.\nmean(array.map(iteratee));\n```\n","src":null,"test":""},{"name":"min","manifest":{"fnSignature":"_.min(array)","lodashLink":"https://lodash.com/docs/4.17.15#min","summary":"Computes the minimum value of `array`. If `array` is empty or falsey, `undefined` is returned."},"description":"```javascript\nMath.min(...array);\n```\n\nThere's a couple of very minor differences in behavior between Lodash's `_.min()`, and JavaScript's native `Math.min()` (apart from the fact that you have to spread your array into JavaScript's version).\n\n1. In Lodash's version, if you provide a falsey value, `undefined` will be returned. In JavaScript, if you try to spread a falsey value into `Math.min()`, you'll get a runtime error, because falsey values aren't iterable. In practice, this difference shouldn't matter much - you should know the types of values you're trying to use, and if you suspect that it might be falsey, just check for that before calling `Math.min()`, instead of checking if the result is undefined after calling `_.min()`.\n\n2. In Lodash's version, if you provide an empty array, `undefined` is returned. In JavaScript, if you spread an empty array, or you provide no arguments, `Infinity` is returned. JavaScript's `Infinity`, while, at first, may sound odd, can actually be a useful return value. It allows you to cleanly write many algorithms capable of operating on empty arrays, without having to explicitly check if the array is empty. Not everyone likes to write algorithms this way, but `Math.min()` gives you the option when it's wanted.","src":null,"test":""},{"name":"minBy","manifest":{"fnSignature":"_.minBy(array, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#minBy","summary":"This method is like `_.min` except that it accepts `iteratee` which is invoked for each element in `array` to generate the criterion by which the value is ranked."},"description":"```javascript\nfunction minBy(array, iteratee) {\n  if (array.length === 0) {\n    return undefined;\n  }\n\n  return array\n    .map(value => ({ value, score: iteratee(value) }))\n    .reduce((best, cur) => cur.score < best.score ? cur : best)\n    .value;\n}\n```\n","src":null,"test":""},{"name":"multiply","manifest":{"fnSignature":"_.multiply(multiplier, multiplicand)","lodashLink":"https://lodash.com/docs/4.17.15#multiply","summary":"Multiply two numbers."},"description":"```javascript\nmultiplier * multiplicand;\n```\n\nOne reason `_.multiply()` exists, is because it's a ready-made function, that can easily be passed into other functions, like this:\n\n```javascript\n> _.reduce([2, 3, 4], _.multiply);\n24\n```\n\nWhen Lodash was first born, the only alternative at the time would be to create an entire function, using the `function` keyword.\n\n```javascript\n_.reduce([2, 3, 4], function (a, b) {\n  return a * b;\n});\n```\n\nSince then, ES6 came out with arrow functions, allowing you to define these sorts of functions in a much more concise way.\n\n```javascript\n_.reduce([2, 3, 4], (a, b) => a * b);\n```\n","src":null,"test":""},{"name":"round","manifest":{"fnSignature":"_.round(number, precision?)","lodashLink":"https://lodash.com/docs/4.17.15#round","summary":"Computes `number` rounded to `precision`."},"description":"If you don't need to use the optional precision argument, then you can simply use the following:\n\n```javascript\nMath.round(number);\n```\n\nOtherwise:\n\n```javascript\nfunction round(number, precision=0) {\n  const factor = 10**precision;\n  return Math.round(number * factor) / factor;\n}\n```\n","src":null,"test":""},{"name":"subtract","manifest":{"fnSignature":"_.subtract(minuend, subtrahend)","lodashLink":"https://lodash.com/docs/4.17.15#subtract","summary":"Subtract two numbers."},"description":"```javascript\nminuend - subtrahend;\n```\n\nOne reason `_.subtract()` exists, is because it's a ready-made function, that can easily be passed into other functions, like this:\n\n```javascript\n> _.reduce([10, 3, 4], _.subtract);\n3\n```\n\nWhen Lodash was first born, the only alternative at the time would be to create an entire function, using the `function` keyword.\n\n```javascript\n_.reduce([10, 3, 4], function (a, b) {\n  return a - b;\n});\n```\n\nSince then, ES6 came out with arrow functions, allowing you to define these sorts of functions in a much more concise way.\n\n```javascript\n_.reduce([10, 3, 4], (a, b) => a - b);\n```\n","src":null,"test":""},{"name":"sum","manifest":{"fnSignature":"_.sum(array)","lodashLink":"https://lodash.com/docs/4.17.15#sum","summary":"Computes the sum of the values in `array`."},"description":"If you want an empty array to throw an error:\n\n```javascript\narray.reduce((a, b) => a + b);\n```\n\nIf you want an empty array to cause `0` to be returned:\n\n```javascript\narray.reduce((a, b) => a + b, 0);\n```\n","src":null,"test":""},{"name":"sumBy","manifest":{"fnSignature":"_.sumBy(array, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#sumBy","summary":"This method is like `_.sum` except that it accepts `iteratee` which is invoked for each element in `array` to generate the value to be summed."},"description":"Simply map over your array with `iteratee`, before trying to sum it:\n\n```javascript\narray\n  .map(iteratee)\n  .reduce((a, b) => a + b);\n```\n","src":null,"test":""}]},{"categoryHeading":"Number","entries":[{"name":"clamp","manifest":{"fnSignature":"_.clamp(number, lower?, upper)","lodashLink":"https://lodash.com/docs/4.17.15#clamp","summary":"Clamps number within the inclusive `lower` and `upper` bounds."},"description":"```javascript\nMath.max(Math.min(number, upper), lower);\n```\n","src":null,"test":""},{"name":"inRange","manifest":{"fnSignature":"_.inRange(number, start?, end)","lodashLink":"https://lodash.com/docs/4.17.15#clamp","summary":"Checks if `n` is between `start` and up to, but not including, `end`. If `start` is greater than `end` the params are swapped to support negative ranges."},"description":"To simply check if a number is between two others, use the following:\n\n```javascript\nstart <= number && number < end;\n```\n\nIf you're uncertain which of the two numbers are lower, use the following:\n\n```javascript\nfunction inRange(number, start, end) {\n  const bounds = start < end\n    ? [start, end]\n    : [end, start];\n\n  return bounds[0] <= number && number < bounds[1];\n}\n```\n","src":null,"test":""},{"name":"random","manifest":{"fnSignature":"_.random(lower?, upper?, floating?)","lodashLink":"https://lodash.com/docs/4.17.15#random","summary":"Produces a random number between the inclusive `lower` and `upper` bounds. If `floating` is true, or either `lower` or `upper` are floats, a floating-point number is returned instead of an integer."},"description":"## For random floats\n\nIf you want a random float between 0 and `upper`:\n\n```javascript\nMath.random() * upper;\n```\n\nIf you want a random float between `lower` and `upper`:\n\n```javascript\nlower + Math.random() * (upper - lower);\n```\n\n## For random integers\n\nAll of these examples will treat `upper` as exclusive, not inclusive. If you want it to be inclusive like it is in Lodash (i.e. you want it to be possible for the upper bound to be returned), add one to `upper`.\n\nIf you want a random integer between 0 and `upper`:\n\n```javascript\nMath.floor(Math.random() * upper);\n```\n\nIf you want a random integer between lower and upper:\n\n```javascript\nlower + Math.floor(Math.random() * (upper - lower));\n```\n","src":null,"test":""}]},{"categoryHeading":"Object","entries":[{"name":"get","manifest":{"fnSignature":"_.get(object, path, defaultValue?)","lodashLink":"https://lodash.com/docs/4.17.15#get","summary":"Gets the value at `path` of `object`. If the resolved value is `undefined`, the `defaultValue` is returned in its place."},"description":"```javascript\nfunction get(object, path, defaultValue = undefined) {\n  // Optional string-path support.\n  // You can remove this `if` block if you don't need it.\n  if (typeof path === 'string') {\n    path = path.split(/[.\\[\\]\\\"]+/).filter(x => x);\n  }\n\n  if (path.length === 0) {\n    return object;\n  }\n\n  const [head, ...tail] = path;\n  if (!(head in object)) {\n    return defaultValue;\n  }\n\n  return get(object[head], tail, defaultValue);\n}\n```\n\nOne of the primary reasons Lodash's `_.get()` function was commonly used, was as a way to easily access a nested property, without having to worry about in-between fields being undefined. This is now possible today using [optional chaining](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining) (`?.`) whenever you suspect a property might be undefined, and the [nullish coalescing operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing) to provide a default value.\n\nFor example, these two are the same:\n\n```javascript\n_.get(obj, 'a.b', null);\n\nobj?.a?.b ?? null;\n```\n\nNote that the support for string paths in the above `get()` implementation isn't very robust. It'll take invalid-looking input, such as `\"prop1.[prop2\"`, ignore the invalid parts, and attempt to work with it anyways. Lodash's `_.get()` isn't all that different in this regard. If you really need support for string inputs, like this, it's recommended to build out your own mini-parser, according to your specific use-cases. For everyone else, there shouldn't be a real reason to need this capability with the modern syntax that JavaScript provides.\n","src":null,"test":""},{"name":"set","manifest":{"fnSignature":"_.set(object, path, value)","lodashLink":"https://lodash.com/docs/4.17.15#set","summary":"Sets the value at `path` of `object`. If a portion of `path` doesn't exist, it's created. Arrays are created for missing index properties while objects are created for all other missing properties."},"description":"```javascript\nfunction set(object, path, value) {\n  // Optional string-path support.\n  // You can remove this `if` block if you don't need it.\n  if (typeof path === 'string') {\n    const isQuoted = str => str[0] === '\"' && str.at(-1) === '\"';\n    path = path.split(/[.\\[\\]]+/)\n      .filter(x => x)\n      .map(x => !isNaN(Number(x)) ? Number(x) : x)\n      .map(x => typeof x === 'string' && isQuoted(x) ? x.slice(1, -1) : x);\n  }\n\n  if (path.length === 0) {\n    throw new Error('The path must have at least one entry in it');\n  }\n\n  const [head, ...tail] = path;\n\n  if (tail.length === 0) {\n    object[head] = value;\n    return;\n  }\n\n  if (!(head in object)) {\n    object[head] = typeof tail[0] === 'number' ? [] : {};\n  }\n\n  return set(object[head], tail, value)\n}\n```\n\nOne of the primary reasons Lodash's `_.set()` function was commonly used, was as a way to easily update a nested property, without having to worry about in-between fields being undefined. This is now possible today using [optional chaining](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining) (`?.`) whenever you suspect a property might be undefined.\n\nFor example, these two are the same:\n\n```javascript\n_.set(obj, 'a.b', true);\n\nobj?.a?.b = true;\n```\n\nNote that the support for string paths in the above `set()` implementation isn't very robust. It'll take invalid-looking input, such as `\"prop1.[prop2\"`, ignore the invalid parts, and attempt to work with it anyways. Lodash's `_.set()` isn't all that different in this regard. If you really need support for string inputs, like this, it's recommended to build out your own mini-parser, according to your specific use-cases. For everyone else, there shouldn't be a real reason to need this capability with the modern syntax that JavaScript provides.\n","src":null,"test":""}]}]