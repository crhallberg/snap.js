[{"categoryHeading":"Array","entries":[{"name":"chunk","manifest":{"fnSignature":"_.chunk(array, size?)","lodashLink":"https://lodash.com/docs/4.17.15#chunk","summary":"Creates an array of elements split into groups the length of `size`. If `array` can't be split evenly, the final chunk will be the remaining elements."},"description":"```javascript\nfunction chunk(array, size = 1) {\n  const result = [];\n  for (let i = 0; i < array.length; i += size) {\n    result.push(array.slice(i, i + size));\n  }\n  return result;\n}\n```\n","src":null,"test":""},{"name":"compact","manifest":{"fnSignature":"_.compact(array)","lodashLink":"https://lodash.com/docs/4.17.15#compact","summary":"Creates an array with all falsey values removed. The values `false`, `null`, `0`, `\"\"`, `undefined`, and `NaN` are falsey."},"description":"All of these solutions are equivalent. Pick the one you find to be the most readable.\n\n```javascript\narray.filter(value => !!value);\n\narray.filter(value => value);\n\narray.filter(Boolean);\n```\n","src":null,"test":""},{"name":"concat","manifest":{"fnSignature":"_.concat(array, ...values)","lodashLink":"https://lodash.com/docs/4.17.15#concat","summary":"Creates a new array concatenating `array` with any additional arrays and/or values."},"description":"```javascript\nconst result = [...array1, ...array2, ...array3];\n```\n\nThis solution above only works on arrays and other iterables. If some of your values might not be arrays, you can use the native `.concat()` method instead.\n\n```javascript\nconst array1 = [1, 2, 3];\nconst value1 = 4;\nconst array2 = [5, 6, 7];\n\nconst result = array1.concat(value1, array2);\n\n// Expected output: [1, 2, 3, 4, 5, 6, 7]\n```\n","src":null,"test":""},{"name":"difference","manifest":{"fnSignature":"_.difference(array, values?)","lodashLink":"https://lodash.com/docs/4.17.15#difference","summary":"Creates an array of `array` values not included in the other given arrays using `SameValueZero` for equality comparisons. The order and references of result values are determined by the first array."},"description":"To subtract everything in array2 from array1, use the following:\n\n```javascript\narray1.filter(x => !array2.includes(x));\n```\n\nRemember that `.includes()` has an `O(n)` lookup time. If you're dealing with larger arrays, make sure to convert the target array into a set first (a set's `.has()` method has `O(1)` lookup time).\n\n```javascript\nconst set2 = new Set(array2);\nconst result = array1.filter(x => !set2.has(x));\n```\n\nBoth `array.includes()` and `set.has()` use [the SameValueZero comparison algorithm](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#same-value-zero_equality) under-the-hood as well, just like Lodash's `_.difference()`.\n","src":null,"test":""},{"name":"differenceBy","manifest":{"fnSignature":"_.differenceBy(array, values?, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#differenceBy","summary":"This method is like `_.difference` except that it accepts `iteratee` which is invoked for each element of `array` and `values` to generate the criterion by which they're compared. The order and references of result values are determined by the first array."},"description":"```javascript\nfunction differenceBy(array, values, iteratee) {\n  const transformedValues = new Set(values.map(x => iteratee(x)));\n  return array.filter(x => !transformedValues.has(iteratee(x)));\n}\n```\n","src":null,"test":""},{"name":"differenceWith","manifest":{"fnSignature":"_.differenceWith(array, values?, comparator?)","lodashLink":"https://lodash.com/docs/4.17.15#differenceWith","summary":"This method is like `_.difference` except that it accepts `comparator` which is invoked to compare elements of `array` to `values`."},"description":"```javascript\nfunction differenceWith(array, values, comparator) {\n  return array.filter(x => !values.some(y => comparator(x, y)));\n}\n```\n","src":null,"test":""},{"name":"drop","manifest":{"fnSignature":"_.drop(array, n?)","lodashLink":"https://lodash.com/docs/4.17.15#drop","summary":"Creates a slice of `array` with `n` elements dropped from the beginning."},"description":"```javascript\narray.slice(n)\n```\n","src":null,"test":""},{"name":"dropRight","manifest":{"fnSignature":"_.dropRight(array, n?)","lodashLink":"https://lodash.com/docs/4.17.15#dropRight","summary":"Creates a slice of `array` with `n` elements dropped from the end."},"description":"```javascript\narray.slice(0, -n)\n```\n\nYou do have to watch out for the zero case. `_.dropRight(0)` will return the whole array, while, `array.slice(0, -0)` will return an empty array.\n","src":null,"test":""},{"name":"dropRightWhile","manifest":{"fnSignature":"_.dropRightWhile(array, predicate?)","lodashLink":"https://lodash.com/docs/4.17.15#dropRightWhile","summary":"Creates a slice of `array` excluding elements dropped from the end. Elements are dropped until `predicate` returns falsey."},"description":"```javascript\nfunction dropRightWhile(array, predicate) {\n  const index = array.findLastIndex((...args) => !predicate(...args))\n  if (index === -1) {\n    return [];\n  }\n\n  return array.slice(0, index + 1);\n}\n```","src":null,"test":""},{"name":"dropWhile","manifest":{"fnSignature":"_.dropWhile(array, predicate?)","lodashLink":"https://lodash.com/docs/4.17.15#dropWhile","summary":"Creates a slice of `array` excluding elements dropped from the beginning. Elements are dropped until `predicate` returns falsey."},"description":"```javascript\nfunction dropWhile(array, predicate) {\n  const index = array.findIndex((...args) => !predicate(...args))\n  if (index === -1) {\n    return [];\n  }\n\n  return array.slice(index);\n}\n```","src":null,"test":""},{"name":"fill","manifest":{"fnSignature":"_.fill(array, value, start?, end?)","lodashLink":"https://lodash.com/docs/4.17.15#fill","summary":"Fills elements of `array` with `value` from `start` up to, but not including, `end`."},"description":"```javascript\narray.fill(value, start, end);\n```\n\nThe `start` and `end` parameters are optional.\n","src":null,"test":""},{"name":"findIndex","manifest":{"fnSignature":"_.findIndex(array, predicate?, fromIndex?)","lodashLink":"https://lodash.com/docs/4.17.15#findIndex","summary":"This method is like `_.find` except that it returns the index of the first element `predicate` returns truthy for instead of the element itself."},"description":"```javascript\narray.findIndex(predicate);\n```\n\nIf you need to start from a particular index, a simple solution is to check which index you're at inside your predicate. In this example, we'll look for the first non-null element that exists at index 5 or greater.\n\n```javascript\narray.findIndex((value, i) => i >= 5 && value !== null);\n```\n\nIf you need to start from a particular index, and you're dealing with larger arrays, you may just need to build your own `findIndex` function from a simple for loop, in order to help with performance.\n","src":null,"test":""},{"name":"findLastIndex","manifest":{"fnSignature":"_.findLastIndex(array, predicate?, fromIndex?)","lodashLink":"https://lodash.com/docs/4.17.15#findLastIndex","summary":"This method is like `_.findIndex` except that it iterates over elements of `collection` from right to left."},"description":"```javascript\narray.findLastIndex(predicate);\n```\n\nIf you need to start from a particular index, a simple solution is to check which index you're at inside your predicate. In this example, we'll look for the first non-null element that exists at index 5 or earlier.\n\n```javascript\narray.findLastIndex((value, i) => i <= 5 && value !== null);\n```\n\nIf you need to start from a particular index, and you're dealing with larger arrays, you may just need to build your own `findLastIndex` function from a simple for loop, in order to help with performance.\n","src":null,"test":""},{"name":"flatten","manifest":{"fnSignature":"_.flatten(array)","lodashLink":"https://lodash.com/docs/4.17.15#flatten","summary":"Flattens `array` a single level deep."},"description":"```javascript\narray.flat();\n```\n","src":null,"test":""},{"name":"flattenDeep","manifest":{"fnSignature":"_.flattenDeep(array)","lodashLink":"https://lodash.com/docs/4.17.15#flattenDeep","summary":"Recursively flattens `array`."},"description":"```javascript\narray.flat(Infinity);\n```\n","src":null,"test":""},{"name":"flattenDepth","manifest":{"fnSignature":"_.flattenDepth(array, depth?)","lodashLink":"https://lodash.com/docs/4.17.15#flattenDeep","summary":"Recursively flatten `array` up to `depth` times."},"description":"```javascript\narray.flat(depth);\n```\n","src":null,"test":""},{"name":"fromPairs","manifest":{"fnSignature":"_.fromPairs(pairs)","lodashLink":"https://lodash.com/docs/4.17.15#fromPairs","summary":"The inverse of `_.toPairs`; this method returns an object composed from key-value `pairs`."},"description":"```javascript\nObject.fromEntries(pairs);\n```\n","src":null,"test":""},{"name":"head","manifest":{"fnSignature":"_.head(array)","lodashLink":"https://lodash.com/docs/4.17.15#head","summary":"Gets the first element of `array`."},"description":"```javascript\narray[0];\n```\n","src":null,"test":""},{"name":"indexOf","manifest":{"fnSignature":"_.indexOf(array, value, fromIndex?)","lodashLink":"https://lodash.com/docs/4.17.15#indexOf","summary":"Gets the index at which the first occurrence of `value` is found in `array` using `SameValueZero` for equality comparisons. If `fromIndex` is negative, it's used as the offset from the end of array."},"description":"```javascript\narray.findIndex(x => x === value);\n```\n\nIf you need to start from a particular index, a simple solution is to check which index you're at inside your predicate. In this example, we'll look for the index of the first `42` that exists at index 5 or greater.\n\n```javascript\narray.findIndex((value, i) => i >= 5 && value === 42);\n```\n\nIf you need to start from a particular index, and you're dealing with larger arrays, you may just need to build your own `findIndex` function using a simple for loop, in order to help with performance.\n\nIf you wish to perform comparisons using [the SameValueZero algorithm](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#same-value-zero_equality), similar to how Lodash does it, you can use this helper function:\n\n```javascript\nfunction sameValueZero(x, y) {\n  return x === y || (Number.isNaN(x) && Number.isNaN(y));\n}\n```\n","src":null,"test":""},{"name":"initial","manifest":{"fnSignature":"_.initial(array)","lodashLink":"https://lodash.com/docs/4.17.15#initial","summary":"Gets all but the last element of `array`."},"description":"```javascript\narray.slice(0, -1)\n```\n","src":null,"test":""},{"name":"intersection","manifest":{"fnSignature":"_.intersection(...arrays)","lodashLink":"https://lodash.com/docs/4.17.15#intersection","summary":"Creates an array of unique values that are included in all given arrays using `SameValueZero` for equality comparisons."},"description":"To take the intersection of array1 and array2, use the following:\n\n```javascript\narray1.filter(x => array2.includes(x));\n```\n\nIf you also wish to remove duplicate elements from the final result, the same way `_.intersection()` does, you can use a set, like so:\n\n```javascript\nconst resultWithDuplicates = array1.filter(x => array2.includes(x));\nconst resultWithoutDuplicates = [...new Set(resultWithDuplicates)];\n```\n\nRemember that `.includes()` has an `O(n)` lookup time. If you're dealing with larger arrays, make sure to convert the second array into a set (a set's `.has()` method has `O(1)` lookup time).\n\n```javascript\nconst set2 = new Set(array2);\nconst resultWithDuplicates = array1.filter(x => set2.has(x));\n```\n\nBoth `array.includes()` and `set.has()` use [the SameValueZero comparison algorithm](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#same-value-zero_equality) under-the-hood as well, just like Lodash's `_.intersection()`.\n\nThere is [an upcoming proposal](https://github.com/tc39/proposal-set-methods) that will introduce a native `.intersection()` method for sets.\n","src":null,"test":""},{"name":"intersectionBy","manifest":{"fnSignature":"_.intersectionBy(...arrays, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#intersectionBy","summary":"This method is like `_.intersection` except that it accepts `iteratee` which is invoked for each element of each `arrays` to generate the criterion by which they're compared."},"description":"```javascript\nfunction intersectionBy(array1, array2, iteratee = x => x) {\n  const result = [];\n  const resultTransformed = new Set();\n  const array2Transformed = new Set(array2.map(x => iteratee(x)));\n  for (const element of array1) {\n    const transformedElement = iteratee(element);\n    const isInIntersection = (\n      !resultTransformed.has(transformedElement)\n      && array2Transformed.has(transformedElement)\n    );\n\n    if (isInIntersection) {\n      result.push(element);\n      resultTransformed.add(transformedElement);\n    }\n  }\n\n  return result;\n}\n```\n\nIf you know that `array1` doesn't contain duplicate elements, or you don't care if duplicate elements from `array1` end up in the final result, then this implementation will achieve the same effect:\n\n```javascript\nfunction intersectionBy(array1, array2, iteratee = x => x) {\n  const array2Transformed = new Set(array2.map(x => iteratee(x)));\n  return array1.filter(x => array2Transformed.has(iteratee(x)));\n}\n```\n","src":null,"test":""},{"name":"intersectionWith","manifest":{"fnSignature":"_.intersectionWith(...arrays, comparator?)","lodashLink":"https://lodash.com/docs/4.17.15#intersectionWith","summary":"This method is like `_.intersection` except that it accepts `comparator` which is invoked to compare elements of `arrays`."},"description":"```javascript\nfunction intersectionWith(array1, array2, comparator) {\n  const result = [];\n  for (const element of array1) {\n    const isInIntersection = (\n      !result.some(x => comparator(x, element))\n      && array2.some(x => comparator(x, element))\n    );\n\n    if (isInIntersection) {\n      result.push(element);\n    }\n  }\n\n  return result;\n}\n```\n\nIf you know that `array1` doesn't contain duplicate elements, or you don't care if duplicate elements from `array1` end up in the final result, then this implementation will achieve the same effect:\n\n```javascript\nfunction intersectionWith(array1, array2, comparator) {\n  return array1.filter(x => array2.some(y => comparator(x, y)));\n}\n```\n","src":null,"test":""},{"name":"join","manifest":{"fnSignature":"_.join(array, separator?)","lodashLink":"https://lodash.com/docs/4.17.15#join","summary":"Converts all elements in `array` into a string separated by `separator`."},"description":"```javascript\narray.join(separator);\n```\n","src":null,"test":""},{"name":"last","manifest":{"fnSignature":"_.last(array)","lodashLink":"https://lodash.com/docs/4.17.15#last","summary":"Gets the last element of `array`."},"description":"```javascript\narray.at(-1);\n```\n","src":null,"test":""},{"name":"lastIndexOf","manifest":{"fnSignature":"_.lastIndexOf(array, value, fromIndex?)","lodashLink":"https://lodash.com/docs/4.17.15#lastIndexOf","summary":"This method is like `_.indexOf` except that it iterates over elements of `array` from right to left."},"description":"```javascript\narray.findLastIndex(x => x === value);\n```\n\nIf you need to start from a particular index, a simple solution is to check which index you're at inside your predicate. In this example, we'll look for the index of the last `42` that exists at index 5 or lower.\n\n```javascript\narray.findLastIndex((value, i) => i <= 5 && value === 42);\n```\n\nIf you need to start from a particular index, and you're dealing with larger arrays, you may just need to build your own `findLastIndex` function using a simple for loop, in order to help with performance.\n\nIf you wish to perform comparisons using [the SameValueZero algorithm](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#same-value-zero_equality), similar to how Lodash does it, you can use this helper function:\n\n```javascript\nfunction sameValueZero(x, y) {\n  return x === y || (Number.isNaN(x) && Number.isNaN(y));\n}\n```\n","src":null,"test":""},{"name":"nth","manifest":{"fnSignature":"_.nth(array, n?)","lodashLink":"https://lodash.com/docs/4.17.15#nth","summary":"Gets the element at index `n` of `array`. If `n` is negative, the nth element from the end is returned."},"description":"```javascript\narray[n];\n```\n\nOr, if you need support for negative indices:\n\n```javascript\narray.at(n);\n```\n","src":null,"test":""},{"name":"pull","manifest":{"fnSignature":"_.pull(array, ...values)","lodashLink":"https://lodash.com/docs/4.17.15#pull","summary":"Removes all given values from `array` using `SameValueZero` for equality comparisons. Note: Unlike `_.without`, this method mutates `array`."},"description":"In general, it's recommended to avoid mutating the original array, but if you must, the following `filterInPlace()` helper can be used to achieve the desired result in `O(n)` time.\n\n```javascript\nfunction filterInPlace(array, predicate) {\n  let destIndex = 0;\n  for (let srcIndex = 0; srcIndex < array.length; ++srcIndex) {\n    if (!predicate(array[srcIndex], srcIndex)) {\n      continue;\n    }\n    array[destIndex] = array[srcIndex]\n    destIndex++;\n  }\n\n  array.splice(destIndex, array.length - destIndex);\n}\n\n// Pull everything out from `array` that equals `targetValue`.\nconst result = filterInPlace(array, x => x === targetValue);\n```\n\nIf you wish to perform comparisons using [the SameValueZero algorithm](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#same-value-zero_equality), similar to how Lodash does it, you can use this helper function:\n\n```javascript\nfunction sameValueZero(x, y) {\n  return x === y || (Number.isNaN(x) && Number.isNaN(y));\n}\n```\n\nSee the `_.pullAll()` entry if you have multiple items you wish to pull at once.\n","src":null,"test":""},{"name":"pullAll","manifest":{"fnSignature":"_.pullAll(array, values)","lodashLink":"https://lodash.com/docs/4.17.15#pullAll","summary":"This method is like `_.pull` except that it accepts an array of values to remove."},"description":"In general, it's recommended to avoid mutating the original array, but if you must, the following `filterInPlace()` helper can be used to achieve the desired result in `O(n)` time.\n\n```javascript\nfunction filterInPlace(array, predicate) {\n  let destIndex = 0;\n  for (let srcIndex = 0; srcIndex < array.length; ++srcIndex) {\n    if (!predicate(array[srcIndex], srcIndex)) {\n      continue;\n    }\n    array[destIndex] = array[srcIndex]\n    destIndex++;\n  }\n\n  array.splice(destIndex, array.length - destIndex);\n}\n\n// Pull everything in the `values` array from `array`.\nconst result = filterInPlace(array, x => values.include(x));\n```\n\nRemember that the `values.includes()` used at the end also has an `O(n)` lookup time. If you're dealing with a larger `values` array, make sure to convert it into a set first (a set's `.has()` method has `O(1)` lookup time).\n\nBoth `array.includes()` and `set.has()` use [the SameValueZero comparison algorithm](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#same-value-zero_equality) under-the-hood as well, just like Lodash's `_.pull()`.\n","src":null,"test":""},{"name":"pullAllBy","manifest":{"fnSignature":"_.pullAllBy(array, values, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#pullAllBy","summary":"This method is like `_.pullAll` except that it accepts `iteratee` which is invoked for each element of `array` and `values` to generate the criterion by which they're compared."},"description":"In general, it's recommended to avoid mutating the original array, but if you must, the following `filterInPlace()` helper can be used to achieve the desired result in `O(n)` time.\n\n```javascript\nfunction filterInPlace(array, predicate) {\n  let destIndex = 0;\n  for (let srcIndex = 0; srcIndex < array.length; ++srcIndex) {\n    if (!predicate(array[srcIndex], srcIndex)) {\n      continue;\n    }\n    array[destIndex] = array[srcIndex]\n    destIndex++;\n  }\n\n  array.splice(destIndex, array.length - destIndex);\n}\n\nfunction pullAllBy(array, values, iteratee) {\n  const transformedValues = new Set(values.map(x => iteratee(x)));\n  filterInPlace(array, x => !transformedValues.has(iteratee(x)));\n}\n```\n","src":null,"test":""},{"name":"pullAllWith","manifest":{"fnSignature":"_.pullAllWith(array, values, comparator?)","lodashLink":"https://lodash.com/docs/4.17.15#pullAllWith","summary":"This method is like `_.pullAll` except that it accepts `comparator` which is invoked to compare elements of `array` to `values`."},"description":"In general, it's recommended to avoid mutating the original array, but if you must, the following `filterInPlace()` helper can be used to achieve the desired result.\n\n```javascript\nfunction filterInPlace(array, predicate) {\n  let destIndex = 0;\n  for (let srcIndex = 0; srcIndex < array.length; ++srcIndex) {\n    if (!predicate(array[srcIndex], srcIndex)) {\n      continue;\n    }\n    array[destIndex] = array[srcIndex]\n    destIndex++;\n  }\n\n  array.splice(destIndex, array.length - destIndex);\n}\n\nfunction pullAllWith(array, values, comparator) {\n  filterInPlace(array, x => !values.some(y => comparator(x, y)));\n}\n```\n","src":null,"test":""},{"name":"pullAt","manifest":{"fnSignature":"_.pullAt(array, indexes?)","lodashLink":"https://lodash.com/docs/4.17.15#pullAt","summary":"Removes elements from `array` corresponding to `indexes` and returns an array of removed elements."},"description":"In general, it's recommended to avoid mutating the original array, but if you must, the following `filterInPlace()` helper can be used to achieve the desired result in `O(n)` time.\n\n```javascript\nfunction filterInPlace(array, predicate) {\n  let destIndex = 0;\n  for (let srcIndex = 0; srcIndex < array.length; ++srcIndex) {\n    if (!predicate(array[srcIndex], srcIndex)) {\n      continue;\n    }\n    array[destIndex] = array[srcIndex]\n    destIndex++;\n  }\n\n  array.splice(destIndex, array.length - destIndex);\n}\n\nfunction pullAt(array, indexes_) {\n  const pulled = indexes_.map(i => array[i]);\n  const indexes = new Set(indexes_);\n  filterInPlace(array, (_, i) => !indexes.has(i));\n  return pulled;\n}\n```\n","src":null,"test":""},{"name":"remove","manifest":{"fnSignature":"_.remove(array, predicate?)","lodashLink":"https://lodash.com/docs/4.17.15#remove","summary":"Removes all elements from `array` that `predicate` returns truthy for and returns an array of the removed elements."},"description":"In general, it's recommended to avoid mutating the original array, but if you must, the following implementation can be used to achieve the desired result in `O(n)` time.\n\n```javascript\nfunction remove(array, predicate) {\n  let destIndex = 0;\n  for (let srcIndex = 0; srcIndex < array.length; ++srcIndex) {\n    if (!predicate(array[srcIndex], srcIndex)) {\n      continue;\n    }\n    array[destIndex] = array[srcIndex]\n    destIndex++;\n  }\n\n  array.splice(destIndex, array.length - destIndex);\n}\n```\n","src":null,"test":""},{"name":"reverse","manifest":{"fnSignature":"_.reverse(array)","lodashLink":"https://lodash.com/docs/4.17.15#reverse","summary":"Reverses `array` so that the first element becomes the last, the second element becomes the second to last, and so on."},"description":"```javascript\narray.reverse();\n```\n","src":null,"test":""},{"name":"slice","manifest":{"fnSignature":"_.slice(array, start?, end?)","lodashLink":"https://lodash.com/docs/4.17.15#slice","summary":"Creates a slice of `array` from `start` up to, but not including, `end`."},"description":"```javascript\narray.slice(start, end);\n```\n\nOne benefit of Lodash's implementation of `.slice()`, is that it'll always return a dense array (as opposed to a [sparse one](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Indexed_collections#sparse_arrays)). The same behavior can be achieved in vanilla JavaScript by simply spreading the array into another one.\n\n```javascript\nconst sparseArray = [2,,3,,4]; // [2, <empty>, 3, <empty>, 4]\nconst denseArray = [...sparseArray]; // [2, undefined, 3, undefined, 4]\nconsole.log(denseArray.slice(1, 3)); // [undefined, 3]\n```\n\nNote, however, that Lodash is providing this behavior, mostly because it makes their `.slice()` implementation more consistent with how newer JavaScript array methods treat sparse arrays - by pretending the holes are the same as `undefined` values. In practice, such a feature shouldn't make a difference in your codebase, as it's generally considered bad practice to create or pass around sparse arrays. If you're a library developer who may be receiving arbitrary user input, simply treat arguments that could potentially be sparse arrays the same way you would treat any other kind of bad input the end-user gives you. If you don't do any data validation, then don't worry about it - a sparse array would result in undefined behavior, the same way any other bad input would. If you do up-front data validation, you can choose to add the detection of sparse arrays as an additional up-front check.\n","src":null,"test":""},{"name":"sortedIndex","manifest":{"fnSignature":"_.sortedIndex(array, value)","lodashLink":"https://lodash.com/docs/4.17.15#sortedIndex","summary":"Uses a binary search to determine the lowest index at which `value` should be inserted into `array` in order to maintain its sort order."},"description":"```javascript\nfunction sortedIndex(array, value, _range) {\n  const [low, high] = _range ?? [0, array.length];\n  if (low === high) {\n    return low;\n  }\n\n  const midPoint = low + Math.floor((high - low) / 2);\n  const newRange = value <= array[midPoint]\n    ? [low, midPoint]\n    : [midPoint + 1, high];\n\n  return sortedIndex(array, value, newRange);\n}\n```\n","src":null,"test":""},{"name":"sortedIndexBy","manifest":{"fnSignature":"_.sortedIndexBy(array, value, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#sortedIndexBy","summary":"This method is like `_.sortedIndex` except that it accepts `iteratee` which is invoked for `value` and each element of `array` to compute their sort ranking."},"description":"```javascript\nfunction sortedIndexBy(array, value, iteratee, _recurseOpts) {\n  _recurseOpts ??= {\n    range: [0, array.length],\n    transformedValue: iteratee(value),\n  };\n\n  const transformedValue = _recurseOpts.transformedValue;\n  const [low, high] = _recurseOpts.range;\n  if (low === high) {\n    return low;\n  }\n\n  const midPoint = low + Math.floor((high - low) / 2);\n  const newRange = transformedValue <= iteratee(array[midPoint])\n    ? [low, midPoint]\n    : [midPoint + 1, high];\n\n  return sortedIndexBy(array, value, iteratee, { transformedValue, range: newRange });\n}\n```\n","src":null,"test":""},{"name":"sortedIndexOf","manifest":{"fnSignature":"_.sortedIndexOf(array, value)","lodashLink":"https://lodash.com/docs/4.17.15#sortedIndexOf","summary":"This method is like `_.indexOf` except that it performs a binary search on a sorted `array`."},"description":"We will use a vanilla JavaScript implementation of `_.sortedIndex()` to help define `sortedIndexOf()`.\n\n```javascript\nfunction sortedIndex(array, value, _range) {\n  const [low, high] = _range ?? [0, array.length];\n  if (low === high) {\n    return low;\n  }\n\n  const midPoint = low + Math.floor((high - low) / 2);\n  const newRange = value <= array[midPoint]\n    ? [low, midPoint]\n    : [midPoint + 1, high];\n\n  return sortedIndex(array, value, newRange);\n}\n\nfunction sortedIndexOf(array, value) {\n  const index = sortedIndex(array, value);\n  return array[index] === value ? index : -1;\n}\n```","src":null,"test":""},{"name":"sortedLastIndex","manifest":{"fnSignature":"_.sortedLastIndex(array, value)","lodashLink":"https://lodash.com/docs/4.17.15#sortedLastIndex","summary":"This method is like `_.sortedIndex` except that it returns the highest index at which `value` should be inserted into `array` in order to maintain its sort order."},"description":"```javascript\nfunction sortedLastIndex(array, value, _range) {\n  const [low, high] = _range ?? [0, array.length];\n  if (low === high) {\n    return low;\n  }\n\n  const midPoint = low + Math.floor((high - low) / 2);\n  const newRange = value < array[midPoint]\n    ? [low, midPoint]\n    : [midPoint + 1, high];\n\n  return sortedLastIndex(array, value, newRange);\n}\n```\n","src":null,"test":""},{"name":"sortedLastIndexBy","manifest":{"fnSignature":"_.sortedLastIndexBy(array, value, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#sortedLastIndexBy","summary":"This method is like `_.sortedLastIndex` except that it accepts `iteratee` which is invoked for value and each element of array to compute their sort ranking."},"description":"```javascript\nfunction sortedLastIndexBy(array, value, iteratee, _recurseOpts) {\n  _recurseOpts ??= {\n    range: [0, array.length],\n    transformedValue: iteratee(value),\n  };\n\n  const transformedValue = _recurseOpts.transformedValue;\n  const [low, high] = _recurseOpts.range;\n  if (low === high) {\n    return low;\n  }\n\n  const midPoint = low + Math.floor((high - low) / 2);\n  const newRange = transformedValue < iteratee(array[midPoint])\n    ? [low, midPoint]\n    : [midPoint + 1, high];\n\n  return sortedLastIndexBy(array, value, iteratee, { transformedValue, range: newRange });\n}\n```\n","src":null,"test":""},{"name":"sortedLastIndexOf","manifest":{"fnSignature":"_.sortedLastIndexOf(array, value)","lodashLink":"https://lodash.com/docs/4.17.15#sortedLastIndexOf","summary":"This method is like `_.lastIndexOf` except that it performs a binary search on a sorted `array`."},"description":"We will use a vanilla JavaScript implementation of `_.sortedLastIndex()` to help define `sortedLastIndexOf()`.\n\n```javascript\nfunction sortedLastIndex(array, value, _range) {\n  const [low, high] = _range ?? [0, array.length];\n  if (low === high) {\n    return low;\n  }\n\n  const midPoint = low + Math.floor((high - low) / 2);\n  const newRange = value < array[midPoint]\n    ? [low, midPoint]\n    : [midPoint + 1, high];\n\n  return sortedLastIndex(array, value, newRange);\n}\n\nfunction sortedLastIndexOf(array, value) {\n  const index = sortedLastIndex(array, value) - 1;\n  return index > -1 && array[index] === value ? index : -1;\n}\n```","src":null,"test":""},{"name":"sortedUniq","manifest":{"fnSignature":"_.sortedUniq(array)","lodashLink":"https://lodash.com/docs/4.17.15#sortedUniq","summary":"This method is like `_.uniq` except that it's designed and optimized for sorted arrays."},"description":"```javascript\nfunction sortedUniq(array) {\n  if (array.length === 0) {\n    return [];\n  }\n\n  const result = [array[0]];\n  for (const value of array) {\n    if (result[result.length - 1] !== value) {\n      result.push(value);\n    }\n  }\n\n  return result;\n}\n```\n\n[Some basic benchmarks](https://gist.github.com/theScottyJam/8424183e49f4555b60752b21f1076129) shows that the processing time per item improves as the number of repeated items increase. If you're not dealing with large arrays, or arrays with many repeated items, then using the simpler `[...new Set(array)]` solution should be sufficient.\n","src":null,"test":""},{"name":"sortedUniqBy","manifest":{"fnSignature":"_.sortedUniqBy(array, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#sortedUniqBy","summary":"This method is like `_.uniqBy` except that it's designed and optimized for sorted arrays."},"description":"```javascript\nfunction sortedUniqBy(array, iteratee) {\n  if (array.length === 0) {\n    return [];\n  }\n\n  let lastTransformedValue = iteratee(array[0]);\n  const result = [array[0]];\n  for (let i = 0; i < array.length; ++i) {\n    const transformedValue = iteratee(array[i]);\n    if (lastTransformedValue !== transformedValue) {\n      result.push(array[i]);\n      lastTransformedValue = transformedValue;\n    }\n  }\n\n  return result;\n}\n```\n","src":null,"test":""},{"name":"tail","manifest":{"fnSignature":"_.tail(array)","lodashLink":"https://lodash.com/docs/4.17.15#tail","summary":"Gets all but the first element of `array`."},"description":"```javascript\narray.slice(1);\n```\n","src":null,"test":""},{"name":"take","manifest":{"fnSignature":"_.take(array, n?)","lodashLink":"https://lodash.com/docs/4.17.15#take","summary":"Creates a slice of `array` with `n` elements taken from the beginning."},"description":"```javascript\narray.slice(0, n);\n```\n","src":null,"test":""},{"name":"takeRight","manifest":{"fnSignature":"_.takeRight(array, n?)","lodashLink":"https://lodash.com/docs/4.17.15#takeRight","summary":"Creates a slice of `array` with `n` elements taken from the end."},"description":"```javascript\narray.slice(-n);\n```\n\nYou do have to watch out for the zero case. `_.takeRight(0)` will return an empty array, while, `array.slice(-0)` will return the whole array.\n","src":null,"test":""},{"name":"takeRightWhile","manifest":{"fnSignature":"_.takeRightWhile(array, predicate?)","lodashLink":"https://lodash.com/docs/4.17.15#takeRightWhile","summary":"Creates a slice of `array` with elements taken from the end. Elements are taken until `predicate` returns falsey."},"description":"```javascript\nfunction takeRightWhile(array, predicate) {\n  const index = array.findLastIndex((...args) => !predicate(...args))\n  if (index === -1) {\n    return array;\n  }\n\n  return array.slice(index + 1);\n}\n```\n","src":null,"test":""},{"name":"takeWhile","manifest":{"fnSignature":"_.takeWhile(array, predicate?)","lodashLink":"https://lodash.com/docs/4.17.15#takeWhile","summary":"Creates a slice of `array` with elements taken from the beginning. Elements are taken until `predicate` returns falsey."},"description":"```javascript\nfunction takeWhile(array, predicate) {\n  const index = array.findIndex((...args) => !predicate(...args))\n  if (index === -1) {\n    return array;\n  }\n\n  return array.slice(0, index);\n}\n```\n","src":null,"test":""},{"name":"union","manifest":{"fnSignature":"_.union(...arrays)","lodashLink":"https://lodash.com/docs/4.17.15#union","summary":"Creates an array of unique values, in order, from all given arrays using `SameValueZero` for equality comparisons."},"description":"```javascript\n[...new Set([...array1, ...array2])];\n```\n\nSets internally use [the SameValueZero comparison algorithm](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#same-value-zero_equality) under-the-hood, just like Lodash's `_.union()`.\n\nThere is [an upcoming proposal](https://github.com/tc39/proposal-set-methods) that will introduce a native `.union()` method for sets.\n","src":null,"test":""},{"name":"unionBy","manifest":{"fnSignature":"_.unionBy(...arrays, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#unionBy","summary":"This method is like `_.union` except that it accepts `iteratee` which is invoked for each element of each `arrays` to generate the criterion by which uniqueness is computed."},"description":"We will use a vanilla JavaScript implementation of `_.uniqBy()` to solve this problem.\n\n```javascript\nfunction uniqBy(array, iteratee) {\n  const transformedResults = new Set();\n  const result = [];\n  for (const element of array) {\n    const transformedElement = iteratee(element);\n    if (!transformedResults.has(transformedElement)) {\n      transformedResults.add(transformedElement);\n      result.push(element);\n    }\n  }\n\n  return result;\n}\n\n// Merge the given arrays, then filter out duplicates.\n// This end-effect will be the union of these two arrays,\n// using `iteratee` to decide equivalence.\nuniqBy([...array1, ...array2], iteratee);\n```\n","src":null,"test":""},{"name":"unionWith","manifest":{"fnSignature":"_.unionWith(array, comparator?)","lodashLink":"https://lodash.com/docs/4.17.15#unionWith","summary":"This method is like `_.union` except that it accepts `comparator` which is invoked to compare elements of `arrays`."},"description":"We will use a vanilla JavaScript implementation of `_.uniqWith()` to solve this problem.\n\n```javascript\nfunction uniqWith(array, comparator) {\n  const result = [];\n  for (const element of array) {\n    if (result.every(x => !comparator(x, element))) {\n      result.push(element);\n    }\n  }\n\n  return result;\n}\n\n// Merge the given arrays, then filter out duplicates.\n// This end-effect will be the union of these two arrays,\n// using `comparator` to decide equivalence.\nuniqWith([...array1, ...array2], comparator);\n```\n","src":null,"test":""},{"name":"uniq","manifest":{"fnSignature":"_.uniq(array)","lodashLink":"https://lodash.com/docs/4.17.15#uniq","summary":"Creates a duplicate-free version of an array, using `SameValueZero` for equality comparisons."},"description":"```javascript\n[...new Set(array)];\n```\n\nSets internally use [the SameValueZero comparison algorithm](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#same-value-zero_equality) under-the-hood, just like Lodash's `_.uniq()`.\n","src":null,"test":""},{"name":"uniqBy","manifest":{"fnSignature":"_.uniqBy(array, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#uniqBy","summary":"This method is like `_.uniq` except that it accepts `iteratee` which is invoked for each element in array to generate the criterion by which uniqueness is computed."},"description":"```javascript\nfunction uniqBy(array, iteratee) {\n  const transformedResults = new Set();\n  const result = [];\n  for (const element of array) {\n    const transformedElement = iteratee(element);\n    if (!transformedResults.has(transformedElement)) {\n      transformedResults.add(transformedElement);\n      result.push(element);\n    }\n  }\n\n  return result;\n}\n```\n","src":null,"test":""},{"name":"uniqWith","manifest":{"fnSignature":"_.uniqWith(array, comparator?)","lodashLink":"https://lodash.com/docs/4.17.15#uniqWith","summary":"This method is like `_.uniq` except that it accepts `comparator` which is invoked to compare elements of `array`."},"description":"```javascript\nfunction uniqWith(array, comparator) {\n  const result = [];\n  for (const element of array) {\n    if (result.every(x => !comparator(x, element))) {\n      result.push(element);\n    }\n  }\n\n  return result;\n}\n```\n","src":null,"test":""},{"name":"unzip","manifest":{"fnSignature":"_.unzip(array)","lodashLink":"https://lodash.com/docs/4.17.15#unzip","summary":"This method is like `_.zip` except that it accepts an array of grouped elements and creates an array regrouping the elements to their pre-zip configuration."},"description":"`_.zip()` is actually the inverse of itself, meaning you can use it to unzip the result of `_.zip()`, like this:\n\n```javascript\nconst original = [[1, 2, 3], ['A', 'B', 'C']]\nconst zipped = _.zip(...original); // [[1, 'A'], [2, 'B'], [3, 'C']]\nconst unzipped = _.zip(...zipped); // [[1, 2, 3], ['A', 'B', 'C']]\n```\n\nThe only difference between `_.zip()` and `_.unzip()` is how it accepts parameters.\n\n```javascript\n// With _.zip(), arrays are passed in as separate parameters\n_.zip([1, 2], ['A', 'B']);     // [[1, 'A'], [2, 'B']]\n// With _.unzip(), arrays are placed inside a single larger array.\n_.unzip([[1, 2], ['A', 'B']]); // [[1, 'A'], [2, 'B']]\n```\n\nSo, to implement an unzip function, all you really need is an implementation for `zip()`.\n\n```javascript\nfunction zip(...arrays) {\n  if (arrays.length === 0) {\n    return [];\n  }\n\n  const minLength = Math.min(...arrays.map(arr => arr.length));\n  const result = [];\n  for (let i = 0; i < minLength; ++i) {\n    result.push(arrays.map(arr => arr[i]));\n  }\n\n  return result;\n}\n```\n\nIf you want a Lodash-style unzip function, here's how to implement it:\n\n```javascript\nfunction unzip(arrays) {\n  return zip(...arrays);\n}\n```\n","src":null,"test":""},{"name":"unzipWith","manifest":{"fnSignature":"_.unzipWith(array, iteratee)","lodashLink":"https://lodash.com/docs/4.17.15#unzipWith","summary":"This method is like `_.unzip` except that it accepts `iteratee` to specify how regrouped values should be combined."},"description":"The only difference between `_.zipWith()` and `_.unzipWith()` is how it accepts parameters.\n\n```javascript\n// With _.zipWith(), arrays are passed in as separate parameters\n_.zipWith([10, 20], [1, 2], (a, b) => a + b);     // [11, 22]\n// With _.unzipWith(), arrays are placed inside a single larger array.\n_.unzipWith([[10, 20], [1, 2]], (a, b) => a + b); // [11, 22]\n```\n\n!!!!\n\nSo, to implement an unzipWith function, all you really need is an implementation for `zipWith()`.\n\n```javascript\nfunction zipWith(...args) {\n  const arrays = args.slice(0, -1);\n  const iteratee = args.at(-1);\n  if (arrays.length === 0) {\n    return [];\n  }\n\n  const minLength = Math.min(...arrays.map(arr => arr.length));\n  const result = [];\n  for (let i = 0; i < minLength; ++i) {\n    result.push(iteratee(...arrays.map(arr => arr[i])));\n  }\n\n  return result;\n}\n```\n\nIf you want a Lodash-style unzipWith function, here's how to implement it:\n\n```javascript\nfunction unzipWith(arrays, iteratee) {\n  return zip(arrays, iteratee);\n}\n```\n","src":null,"test":""},{"name":"without","manifest":{"fnSignature":"_.without(array, ...values)","lodashLink":"https://lodash.com/docs/4.17.15#without","summary":"Creates an array excluding all given values using `SameValueZero` for equality comparisons."},"description":"```javascript\narray.filter(x => x !== value);\n```\n\nIf you wish to filter out multiple values, look at the vanilla JavaScript version of `_.difference()`. Both `_.difference()` and _.without()` achieve the same effect, but with slightly different function signatures.\n\nIf you wish to perform comparisons using [the SameValueZero algorithm](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#same-value-zero_equality), similar to how Lodash does it, you can use this helper function:\n\n```javascript\nfunction sameValueZero(x, y) {\n  return x === y || (Number.isNaN(x) && Number.isNaN(y));\n}\n```\n","src":null,"test":""},{"name":"xor","manifest":{"fnSignature":"_.xor(...arrays)","lodashLink":"https://lodash.com/docs/4.17.15#xor","summary":"Creates an array of unique values that is the symmetric difference of the given arrays."},"description":"```javascript\nfunction xor(array1, array2) {\n  const set1 = new Set(array1);\n  const set2 = new Set(array2);\n  return [\n    ...array1.filter(x => !set2.has(x)),\n    ...array2.filter(x => !set1.has(x)),\n  ];\n}\n```\n","src":null,"test":""},{"name":"xorBy","manifest":{"fnSignature":"_.xorBy(...arrays, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#xorBy","summary":"This method is like `_.xor` except that it accepts `iteratee` which is invoked for each element of each `arrays` to generate the criterion by which by which they're compared."},"description":"```javascript\nfunction xorBy(array1, array2, predicate) {\n  const set1 = new Set(array1.map(x => predicate(x)));\n  const set2 = new Set(array2.map(x => predicate(x)));\n  return [\n    ...array1.filter(x => !set2.has(predicate(x))),\n    ...array2.filter(x => !set1.has(predicate(x))),\n  ];\n}\n```\n","src":null,"test":""},{"name":"xorWith","manifest":{"fnSignature":"_.xorWith(...arrays, comparator?)","lodashLink":"https://lodash.com/docs/4.17.15#xorWith","summary":"This method is like `_.xor` except that it accepts `comparator` which is invoked to compare elements of arrays."},"description":"```javascript\nfunction xorWith(array1, array2, comparator) {\n  return [\n    ...array1.filter(x => !array2.some(y => comparator(x, y))),\n    ...array2.filter(x => !array1.some(y => comparator(x, y))),\n  ];\n}\n```\n","src":null,"test":""},{"name":"zip","manifest":{"fnSignature":"_.zip(...arrays)","lodashLink":"https://lodash.com/docs/4.17.15#zip","summary":"Creates an array of grouped elements, the first of which contains the first elements of the given arrays, the second of which contains the second elements of the given arrays, and so on."},"description":"```javascript\nfunction zip(...arrays) {\n  if (arrays.length === 0) {\n    return [];\n  }\n\n  const minLength = Math.min(...arrays.map(arr => arr.length));\n  const result = [];\n  for (let i = 0; i < minLength; ++i) {\n    result.push(arrays.map(arr => arr[i]));\n  }\n\n  return result;\n}\n```\n","src":null,"test":""},{"name":"zipObject","manifest":{"fnSignature":"_.zipObject(props?, values?)","lodashLink":"https://lodash.com/docs/4.17.15#zipObject","summary":"This method is like `_.fromPairs` except that it accepts two arrays, one of property identifiers and one of corresponding values."},"description":"We will use a vanilla JavaScript implementation of `_.zip()` to solve this problem.\n\n```javascript\nfunction zip(...arrays) {\n  if (arrays.length === 0) {\n    return [];\n  }\n\n  const minLength = Math.min(...arrays.map(arr => arr.length));\n  const result = [];\n  for (let i = 0; i < minLength; ++i) {\n    result.push(arrays.map(arr => arr[i]));\n  }\n\n  return result;\n}\n\n// First zips the keys and values,\n// then build an object from the zipped entries.\nObject.fromEntries(zip(props, values));\n```\n","src":null,"test":""},{"name":"zipObjectDeep","manifest":{"fnSignature":"_.zipObjectDeep(props?, values?)","lodashLink":"https://lodash.com/docs/4.17.15#zipObjectDeep","summary":"This method is like `_.zipObject` except that it supports property paths."},"description":"It's recommended to avoid this function. Building objects via dynamic string paths may (or may not) be indicative of a deeper issue with how the problem is being approached. But, if you really do need support for this sort of thing, it can be done, with the help of the vanilla JavaScript implementation of `_.set()` and `_.zip()`.\n\n```javascript\nfunction set(object, path, value) {\n  if (typeof path === 'string') {\n    const isQuoted = str => str[0] === '\"' && str.at(-1) === '\"';\n    path = path.split(/[.\\[\\]]+/)\n      .filter(x => x)\n      .map(x => !isNaN(Number(x)) ? Number(x) : x)\n      .map(x => typeof x === 'string' && isQuoted(x) ? x.slice(1, -1) : x);\n  }\n\n  if (path.length === 0) {\n    throw new Error('The path must have at least one entry in it');\n  }\n\n  const [head, ...tail] = path;\n\n  if (tail.length === 0) {\n    object[head] = value;\n    return object;\n  }\n\n  if (!(head in object)) {\n    object[head] = typeof tail[0] === 'number' ? [] : {};\n  }\n\n  set(object[head], tail, value);\n  return object;\n}\n\nfunction zip(...arrays) {\n  if (arrays.length === 0) {\n    return [];\n  }\n\n  const minLength = Math.min(...arrays.map(arr => arr.length));\n  const result = [];\n  for (let i = 0; i < minLength; ++i) {\n    result.push(arrays.map(arr => arr[i]));\n  }\n\n  return result;\n}\n\nfunction zipObjectDeep(props, values) {\n  const resultObj = {};\n  for (const [path, value] of zip(props, values)) {\n    set(resultObj, path, value);\n  }\n\n  return resultObj;\n}\n```\n\nNote that the support for string paths in the above `zipObjectDeep()` implementation isn't very robust. It'll take invalid-looking input, such as `\"prop1.[prop2\"`, ignore the invalid parts, and attempt to work with it anyways. Lodash's `_.zipObjectDeep()` isn't all that different in this regard.\n","src":null,"test":""},{"name":"zipWith","manifest":{"fnSignature":"_.zipWith(...arrays, iteratee)","lodashLink":"https://lodash.com/docs/4.17.15#zipWith","summary":"This method is like `_.zip` except that it accepts `iteratee` to specify how grouped values should be combined."},"description":"```javascript\nfunction zipWith(...args) {\n  const arrays = args.slice(0, -1);\n  const iteratee = args.at(-1);\n  if (arrays.length === 0) {\n    return [];\n  }\n\n  const minLength = Math.min(...arrays.map(arr => arr.length));\n  const result = [];\n  for (let i = 0; i < minLength; ++i) {\n    result.push(iteratee(...arrays.map(arr => arr[i])));\n  }\n\n  return result;\n}\n```\n","src":null,"test":""}]},{"categoryHeading":"Date","entries":[{"name":"now","manifest":{"fnSignature":"_.now()","lodashLink":"https://lodash.com/docs/4.17.15#now","summary":"Gets the timestamp of the number of milliseconds that have elapsed since the Unix epoch."},"description":"```javascript\nDate.now();\n```\n","src":null,"test":""}]},{"categoryHeading":"Lang","entries":[{"name":"cloneDeep","manifest":{"fnSignature":"_.cloneDeep(value)","lodashLink":"https://lodash.com/docs/4.17.15#cloneDeep","summary":"This method is like `_.clone` except that it recursively clones value."},"description":"```javascript\nstructuredClone(value)\n```\n\nUsing `structuredClone()` (or `_.cloneDeep()`) can be useful for simpler scenarios, but they both also have severe limitations in their capabilities that you should be aware of. For example:\n* many objects, such as `ArrayBuffer` instances, will have ownership of their data transferred to their clone, rendering the original unusable. A complete list of transferable objects can be found [on MDN's website](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Transferable_objects#supported_objects).\n* Some values, like functions, can not be cloned.\n* Some objects loose data when they get cloned. This includes the prototypes of most objects (making it impossible to properly clone instances of any userland class), getters and setters, some data stored on regular expression instances, etc.\n\nFor a complete reference to the algorithm's limitations, please refer to the [structured clone algorithm page](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm) on MDN.\n\n\nIf `structuredClone()` doesn't suit your needs (because, e.g., maybe you have userland instances that you wish to clone), you'll have to build up your own cloning algorithm by hand, according to your use-case. Here's a simple version to get you started - it shows examples of how you would deep-clone a handful of different types of data. It's up to you to add or remove functionality as needed. Note that this version does not support circular references - if you need to support that, you'll additionally need to keep around a stack of each value you've visited, to make sure you're not going in a loop.\n\n```javascript\nconst isObject = value => typeof value === 'object' && value !== null;\n\nfunction cloneDeep(value) {\n  if (!isObject(value)) {\n    // It's a primitive, which is immutable, so we don't need to clone it.\n    return value;\n  }\n\n  if (Array.isArray(value)) {\n    return value.map(cloneDeep);\n  } else if (value instanceof Map) {\n    return new Map(\n      [...value].map(([key, value]) => [cloneDeep(key), cloneDeep(value)])\n    );\n  } else if (value instanceof Set) {\n    return new Set(\n      [...value].map(x => cloneDeep(x))\n    );\n  } else if (Object.getPrototypeOf(value) === Object.prototype) {\n    return Object.fromEntries(\n      Object.entries(value).map(([key, value]) => [key, cloneDeep(value)])\n    );\n  } else if (Object.getPrototypeOf(value) === null) {\n    const newObject = Object.fromEntries(\n      Object.entries(value).map(([key, value]) => [key, cloneDeep(value)])\n    );\n    Object.setPrototypeOf(newObject, null);\n    return newObject\n  } else {\n    throw new Error(`Can not clone an instance of ${value.constructor?.name}`);\n  }\n}\n```\n","src":null,"test":""}]},{"categoryHeading":"Math","entries":[{"name":"add","manifest":{"fnSignature":"_.add(augend, addend)","lodashLink":"https://lodash.com/docs/4.17.15#add","summary":"Adds two numbers."},"description":"```javascript\naugend + addend;\n```\n\nOne reason `_.add()` exists, is because it's a ready-made function, that can easily be passed into other functions, like this:\n\n```javascript\n> _.reduce([2, 3, 4], _.add);\n9\n```\n\nWhen Lodash was first born, the only alternative at the time would be to create an entire function, using the `function` keyword.\n\n```javascript\n_.reduce([2, 3, 4], function (a, b) {\n  return a + b;\n});\n```\n\nSince then, ES6 came out with arrow functions, allowing you to define these sorts of functions in a much more concise way.\n\n```javascript\n_.reduce([2, 3, 4], (a, b) => a + b);\n```\n","src":null,"test":""},{"name":"ceil","manifest":{"fnSignature":"_.ceil(number, precision?)","lodashLink":"https://lodash.com/docs/4.17.15#ceil","summary":"Computes `number` rounded up to `precision`."},"description":"If you don't need to use the optional precision argument, then you can simply use the following:\n\n```javascript\nMath.ceil(number);\n```\n\nOtherwise:\n\n```javascript\nfunction ceil(number, precision=0) {\n  const factor = 10**precision;\n  return Math.ceil(number * factor) / factor;\n}\n```","src":null,"test":""},{"name":"divide","manifest":{"fnSignature":"_.divide(dividend, divisor)","lodashLink":"https://lodash.com/docs/4.17.15#divide","summary":"Divide two numbers."},"description":"```javascript\naugend / addend;\n```\n\nOne reason `_.divide()` exists, is because it's a ready-made function, that can easily be passed into other functions, like this:\n\n```javascript\n> _.reduce([100, 2, 5], _.divide);\n10\n```\n\nWhen Lodash was first born, the only alternative at the time would be to create an entire function, using the `function` keyword.\n\n```javascript\n_.reduce([100, 2, 5], function (a, b) {\n  return a / b;\n});\n```\n\nSince then, ES6 came out with arrow functions, allowing you to define these sorts of functions in a much more concise way.\n\n```javascript\n_.reduce([100, 2, 5], (a, b) => a / b);\n```\n","src":null,"test":""},{"name":"floor","manifest":{"fnSignature":"_.floor(number, precision?)","lodashLink":"https://lodash.com/docs/4.17.15#floor","summary":"Computes `number` rounded down to `precision`."},"description":"If you don't need to use the optional precision argument, then you can simply use the following:\n\n```javascript\nMath.floor(number);\n```\n\nOtherwise:\n\n```javascript\nfunction floor(number, precision=0) {\n  const factor = 10**precision;\n  return Math.floor(number * factor) / factor;\n}\n```","src":null,"test":""},{"name":"max","manifest":{"fnSignature":"_.max(array)","lodashLink":"https://lodash.com/docs/4.17.15#max","summary":"Computes the maximum value of array. If array is empty or falsey, undefined is returned."},"description":"```javascript\nMath.max(...array);\n```\n\nThere's a couple of very minor differences in behavior between Lodash's `_.max()`, and JavaScript's native `Math.max()` (apart from the fact that you have to spread your array into JavaScript's version).\n\n1. In Lodash's version, if you provide a falsey value, `undefined` will be returned. In JavaScript, if you try to spread a falsey value into `Math.max()`, you'll get a runtime error, because falsey values aren't iterable. In practice, this difference shouldn't matter much - you should know the types of values you're trying to use, and if you suspect that it might be falsey, just check for that before calling `Math.max()`, instead of checking if the result is undefined after calling `_.max()`.\n\n2. In Lodash's version, if you provide an empty array, `undefined` is returned. In JavaScript, if you spread an empty array, or you provide no arguments, `-Infinity` is returned. JavaScript's `-Infinity`, while, at first, may sound odd, can actually be a useful return value. It allows you to cleanly write many algorithms capable of operating on empty arrays, without having to explicitly check if the array is empty. Not everyone likes to write algorithms this way, but `Math.max()` gives you the option when it's wanted.","src":null,"test":""},{"name":"maxBy","manifest":{"fnSignature":"_.maxBy(array, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#maxBy","summary":"This method is like `_.max` except that it accepts `iteratee` which is invoked for each element in `array` to generate the criterion by which the value is ranked."},"description":"```javascript\nfunction maxBy(array, iteratee) {\n  if (array.length === 0) {\n    return undefined;\n  }\n\n  return array\n    .map(value => ({ value, score: iteratee(value) }))\n    .reduce((best, cur) => cur.score > best.score ? cur : best)\n    .value;\n}\n```\n","src":null,"test":""},{"name":"mean","manifest":{"fnSignature":"_.mean(array)","lodashLink":"https://lodash.com/docs/4.17.15#mean","summary":"Computes the mean of the values in array."},"description":"```javascript\nfunction mean(array) {\n  return array.reduce((a, b) => a + b) / array.length;\n}\n```\n","src":null,"test":""},{"name":"meanBy","manifest":{"fnSignature":"_.meanBy(array, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#meanBy","summary":"This method is like `_.mean` except that it accepts `iteratee` which is invoked for each element in `array` to generate the value to be averaged."},"description":"We will use a vanilla JavaScript implementation of `_.mean()` to solve this problem.\n\n```javascript\nfunction mean(array) {\n  return array.reduce((a, b) => a + b) / array.length;\n}\n\n// Uses `iteratee` on each element of the array, to convert them to\n// new values, before taking the mean.\nmean(array.map(iteratee));\n```\n","src":null,"test":""},{"name":"min","manifest":{"fnSignature":"_.min(array)","lodashLink":"https://lodash.com/docs/4.17.15#min","summary":"Computes the minimum value of `array`. If `array` is empty or falsey, `undefined` is returned."},"description":"```javascript\nMath.min(...array);\n```\n\nThere's a couple of very minor differences in behavior between Lodash's `_.min()`, and JavaScript's native `Math.min()` (apart from the fact that you have to spread your array into JavaScript's version).\n\n1. In Lodash's version, if you provide a falsey value, `undefined` will be returned. In JavaScript, if you try to spread a falsey value into `Math.min()`, you'll get a runtime error, because falsey values aren't iterable. In practice, this difference shouldn't matter much - you should know the types of values you're trying to use, and if you suspect that it might be falsey, just check for that before calling `Math.min()`, instead of checking if the result is undefined after calling `_.min()`.\n\n2. In Lodash's version, if you provide an empty array, `undefined` is returned. In JavaScript, if you spread an empty array, or you provide no arguments, `Infinity` is returned. JavaScript's `Infinity`, while, at first, may sound odd, can actually be a useful return value. It allows you to cleanly write many algorithms capable of operating on empty arrays, without having to explicitly check if the array is empty. Not everyone likes to write algorithms this way, but `Math.min()` gives you the option when it's wanted.","src":null,"test":""},{"name":"minBy","manifest":{"fnSignature":"_.minBy(array, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#minBy","summary":"This method is like `_.min` except that it accepts `iteratee` which is invoked for each element in `array` to generate the criterion by which the value is ranked."},"description":"```javascript\nfunction minBy(array, iteratee) {\n  if (array.length === 0) {\n    return undefined;\n  }\n\n  return array\n    .map(value => ({ value, score: iteratee(value) }))\n    .reduce((best, cur) => cur.score < best.score ? cur : best)\n    .value;\n}\n```\n","src":null,"test":""},{"name":"multiply","manifest":{"fnSignature":"_.multiply(multiplier, multiplicand)","lodashLink":"https://lodash.com/docs/4.17.15#multiply","summary":"Multiply two numbers."},"description":"```javascript\nmultiplier * multiplicand;\n```\n\nOne reason `_.multiply()` exists, is because it's a ready-made function, that can easily be passed into other functions, like this:\n\n```javascript\n> _.reduce([2, 3, 4], _.multiply);\n24\n```\n\nWhen Lodash was first born, the only alternative at the time would be to create an entire function, using the `function` keyword.\n\n```javascript\n_.reduce([2, 3, 4], function (a, b) {\n  return a * b;\n});\n```\n\nSince then, ES6 came out with arrow functions, allowing you to define these sorts of functions in a much more concise way.\n\n```javascript\n_.reduce([2, 3, 4], (a, b) => a * b);\n```\n","src":null,"test":""},{"name":"round","manifest":{"fnSignature":"_.round(number, precision?)","lodashLink":"https://lodash.com/docs/4.17.15#round","summary":"Computes `number` rounded to `precision`."},"description":"If you don't need to use the optional precision argument, then you can simply use the following:\n\n```javascript\nMath.round(number);\n```\n\nOtherwise:\n\n```javascript\nfunction round(number, precision=0) {\n  const factor = 10**precision;\n  return Math.round(number * factor) / factor;\n}\n```\n","src":null,"test":""},{"name":"subtract","manifest":{"fnSignature":"_.subtract(minuend, subtrahend)","lodashLink":"https://lodash.com/docs/4.17.15#subtract","summary":"Subtract two numbers."},"description":"```javascript\nminuend - subtrahend;\n```\n\nOne reason `_.subtract()` exists, is because it's a ready-made function, that can easily be passed into other functions, like this:\n\n```javascript\n> _.reduce([10, 3, 4], _.subtract);\n3\n```\n\nWhen Lodash was first born, the only alternative at the time would be to create an entire function, using the `function` keyword.\n\n```javascript\n_.reduce([10, 3, 4], function (a, b) {\n  return a - b;\n});\n```\n\nSince then, ES6 came out with arrow functions, allowing you to define these sorts of functions in a much more concise way.\n\n```javascript\n_.reduce([10, 3, 4], (a, b) => a - b);\n```\n","src":null,"test":""},{"name":"sum","manifest":{"fnSignature":"_.sum(array)","lodashLink":"https://lodash.com/docs/4.17.15#sum","summary":"Computes the sum of the values in `array`."},"description":"If you want an empty array to throw an error:\n\n```javascript\narray.reduce((a, b) => a + b);\n```\n\nIf you want an empty array to cause `0` to be returned:\n\n```javascript\narray.reduce((a, b) => a + b, 0);\n```\n","src":null,"test":""},{"name":"sumBy","manifest":{"fnSignature":"_.sumBy(array, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#sumBy","summary":"This method is like `_.sum` except that it accepts `iteratee` which is invoked for each element in `array` to generate the value to be summed."},"description":"Simply map over your array with `iteratee`, before trying to sum it:\n\n```javascript\narray\n  .map(iteratee)\n  .reduce((a, b) => a + b);\n```\n","src":null,"test":""}]},{"categoryHeading":"Number","entries":[{"name":"clamp","manifest":{"fnSignature":"_.clamp(number, lower?, upper)","lodashLink":"https://lodash.com/docs/4.17.15#clamp","summary":"Clamps number within the inclusive `lower` and `upper` bounds."},"description":"```javascript\nMath.max(Math.min(number, upper), lower);\n```\n","src":null,"test":""},{"name":"inRange","manifest":{"fnSignature":"_.inRange(number, start?, end)","lodashLink":"https://lodash.com/docs/4.17.15#clamp","summary":"Checks if `n` is between `start` and up to, but not including, `end`. If `start` is greater than `end` the params are swapped to support negative ranges."},"description":"To simply check if a number is between two others, use the following:\n\n```javascript\nstart <= number && number < end;\n```\n\nIf you're uncertain which of the two numbers are lower, use the following:\n\n```javascript\nfunction inRange(number, start, end) {\n  const bounds = start < end\n    ? [start, end]\n    : [end, start];\n\n  return bounds[0] <= number && number < bounds[1];\n}\n```\n","src":null,"test":""},{"name":"random","manifest":{"fnSignature":"_.random(lower?, upper?, floating?)","lodashLink":"https://lodash.com/docs/4.17.15#random","summary":"Produces a random number between the inclusive `lower` and `upper` bounds. If `floating` is true, or either `lower` or `upper` are floats, a floating-point number is returned instead of an integer."},"description":"## For random floats\n\nIf you want a random float between 0 and `upper`:\n\n```javascript\nMath.random() * upper;\n```\n\nIf you want a random float between `lower` and `upper`:\n\n```javascript\nlower + Math.random() * (upper - lower);\n```\n\n## For random integers\n\nAll of these examples will treat `upper` as exclusive, not inclusive. If you want it to be inclusive like it is in Lodash (i.e. you want it to be possible for the upper bound to be returned), add one to `upper`.\n\nIf you want a random integer between 0 and `upper`:\n\n```javascript\nMath.floor(Math.random() * upper);\n```\n\nIf you want a random integer between lower and upper:\n\n```javascript\nlower + Math.floor(Math.random() * (upper - lower));\n```\n","src":null,"test":""}]},{"categoryHeading":"Object","entries":[{"name":"assign","manifest":{"fnSignature":"_.assign(object, ...sources)","lodashLink":"https://lodash.com/docs/4.17.15#assign","summary":"Assigns own enumerable string keyed properties of source objects to the destination object."},"description":"```javascript\nObject.assign(object, sourceObj1, sourceObj2);\n```\n\nOr, if all you want to do is merge objects together, and you don't wish to mutate anything, you can use the spread syntax.\n\n```javascript\n{ ...sourceObj1, ...sourceObj2 };\n```","src":null,"test":""},{"name":"assignIn","manifest":{"fnSignature":"_.assignIn(object, ...sources)","lodashLink":"https://lodash.com/docs/4.17.15#assignIn","summary":"This method is like `_.assign` except that it iterates over own and inherited source properties."},"description":"```javascript\nfunction assignIn(object, ...sources) {\n  for (const source of sources) {\n    for (const key in source) {\n      object[key] = source[key];\n    }\n  }\n\n  return object;\n}\n```\n\nIt's very likely that you don't actually need this function. The only way this function is different from `_.assign()` (or `Object.assign()`), is that it'll also copy over non-enumerable inherited fields. But...\n1. Class syntax will automatically make all methods on the prototype chain non-enumerable, which means the `assignIn()` function won't copy them anyways. Even if you achieve inheritance other ways (by manually messing with the prototypes), it can be argued that it's more proper to make the methods on the prototype non-enumerable.\n2. Why are you even trying to copy both the data and the inherited methods off of an object? If you want one object to share the same methods as another object, consider using normal inheritance.\n\nPerhaps there's some niche use-cases for this sort of function that arise from fairly abnormal and tricky uses of the JavaScript prototype, but, for day-to-day development, it's best to stay away from this function. If you just want to copy data over from one object to another, please look at `_.assign()` instead.\n","src":null,"test":""},{"name":"assignInWith","manifest":{"fnSignature":"_.assignInWith(object, ...sources, customizer)","lodashLink":"https://lodash.com/docs/4.17.15#assignInWith","summary":"This method is like `_.assignIn` except that it accepts `customizer` which is invoked to produce the assigned values. If `customizer` returns `undefined`, assignment is handled by the method instead."},"description":"```javascript\nfunction assignInWith(object, sources, customizer) {\n  for (const source of sources) {\n    for (const key in source) {\n      const customizerResult = customizer(object[key], value, key, object, source);\n      object[key] = customizerResult !== undefined ? customizerResult : source[key];\n    }\n  }\n\n  return object;\n}\n```\n\nIt's very likely that you don't actually need this function. The only way this function is different from `_.assignWith()`, is that it'll also copy over non-enumerable inherited fields. But class syntax will automatically make all methods on the prototype chain non-enumerable, which means the `assignInWith()` function won't copy them anyways. Even if you achieve inheritance other ways (by manually messing with the prototypes), it can be argued that it's more proper to make the methods on the prototype non-enumerable.\n\nPerhaps there's some niche use-cases for this sort of function that arise from fairly abnormal and tricky uses of the JavaScript prototype, but, for day-to-day development, it's best to stay away from this function. If you just want to copy data over from one object to another with a customizer function (and don't need to worry about inherited fields), please look at the JavaScript equivalent to `_.assignWith()` instead.\n","src":null,"test":""},{"name":"assignWith","manifest":{"fnSignature":"_.assignWith(object, ...sources, customizer?)","lodashLink":"https://lodash.com/docs/4.17.15#assignWith","summary":"This method is like `_.assign` except that it accepts `customizer` which is invoked to produce the assigned values. If `customizer` returns `undefined`, assignment is handled by the method instead."},"description":"A complete implementation would look like this:\n\n```javascript\nfunction assignWith(object, sources, customizer) {\n  for (const source of sources) {\n    for (const [key, value] of Object.entries(source)) {\n      const customizerResult = customizer(object[key], value, key, object, source);\n      object[key] = customizerResult !== undefined ? customizerResult : source[key];\n    }\n  }\n\n  return object;\n}\n```\n\nHowever, it's possible that all you really need to do is map over your source objects before merging them, like this:\n\n```javascript\n// Merge your sources together, then map over each entry, updating them as you map over them.\nconst updatedEntries = Object.entries({ ...source1, ...source2, ...source3 })\n  .map(([key, value]) => [key, ...operate on `value` however you want...]);\n\n// Construct a new object from the mapped entries\nconst updatedSource = Object.fromEntries(updatedEntries);\n\n// If needed, assign the updated entries to `object`, mutating it so it contains this new data.\nObject.assign(object, updatedSource);\n```\n","src":null,"test":""},{"name":"at","manifest":{"fnSignature":"_.at(object, paths?)","lodashLink":"https://lodash.com/docs/4.17.15#at","summary":"Creates an array of values corresponding to `paths` of `object`."},"description":"We will use a vanilla JavaScript implementation of `_.get()` to solve this problem.\n\n```javascript\nfunction get(object, path, defaultValue = undefined) {\n  // Optional string-path support.\n  // You can remove this `if` block if you don't need it.\n  if (typeof path === 'string') {\n    path = path.split(/[.\\[\\]\\\"]+/).filter(x => x);\n  }\n\n  if (path.length === 0) {\n    return object;\n  }\n\n  const [head, ...tail] = path;\n  if (!(head in object)) {\n    return defaultValue;\n  }\n\n  return get(object[head], tail, defaultValue);\n}\n\n// Maps over the paths array, fetching each field value from `object` corresponding to that path.\npaths.map(path => get(object, path));\n```\n\nOne of the primary reasons Lodash's `_.get()` function was commonly used, was as a way to easily access a nested property without having to worry about in-between fields being undefined. This is now possible today using [optional chaining](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining) (`?.`) whenever you suspect a property might be undefined, and the [nullish coalescing operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing) to provide a default value.\n\nFor example, these two are the same:\n\n```javascript\n_.get(obj, 'a.b', null);\n\nobj?.a?.b ?? null;\n```\n\nNote that the support for string paths in the above `get()` implementation isn't very robust. It'll take invalid-looking input, such as `\"prop1.[prop2\"`, ignore the invalid parts, and attempt to work with it anyways. Lodash's `_.get()` and `_.at()` isn't all that different in this regard. If you really need support for string inputs, like this, it's recommended to build out your own mini-parser, according to your specific use-cases. For everyone else, there shouldn't be a real reason to need this capability with the modern syntax that JavaScript provides.\n","src":null,"test":""},{"name":"create","manifest":{"fnSignature":"_.create(prototype, properties?)","lodashLink":"https://lodash.com/docs/4.17.15#create","summary":"Creates an object that inherits from the `prototype` object. If a `properties` object is given, its own enumerable string keyed properties are assigned to the created object."},"description":"If you just need to create an object that inherits from another object:\n\n```javascript\nObject.create(prototype)\n```\n\nIf you also need to assign some fields to the newly created object, either of these options work:\n\n```javascript\nObject.assign(Object.create(prototype), properties);\n\nObject.create(prototype, Object.getOwnPropertyDescriptors(properties));\n```\n","src":null,"test":""},{"name":"defaults","manifest":{"fnSignature":"_.defaults(object, ...sources)","lodashLink":"https://lodash.com/docs/4.17.15#defaults","summary":"Assigns own and inherited enumerable string keyed properties of source objects to the destination object for all destination properties that resolve to `undefined`. Source objects are applied from left to right. Once a property is set, additional values of the same property are ignored."},"description":"There's a handful of different patterns that can be used when you need to apply default values to your object. Each of these methods will handle `null`, `undefined`, and absent properties differently.\n\n1. Destructuring with defaults\n\nDefaults will be applied if the properties on `object` are absent or set to `undefined`.\n\n```javascript\nfunction addDefaultValues(object) {\n  const {\n    prop1 = 'default 1',\n    prop2 = 'default 2',\n    prop3 = 'default 3',\n  } = object;\n\n  return { prop1, prop2, prop3 };\n}\n```\n\n2. Using the nullish coalescing operator (`??`)\n\nDefaults will be applied if the properties on `object` are absent, set to `undefined`, or set to `null`.\n\n```javascript\nconst result = {\n  prop1: object.prop1 ?? 'default 1',\n  prop2: object.prop2 ?? 'default 2',\n  prop3: object.prop3 ?? 'default 3',\n};\n```\n\n3. Spreading a defaults object with your target object\n\nDefaults will only be applied if the properties on `object` are absent.\n\n```javascript\nconst defaults = {\n  prop1: 'default 1',\n  prop2: 'default 2',\n  prop3: 'default 3',\n};\n\n// Note that if you happen to have multiple objects with defaults, you can easily\n// spread them all together here.\nconst result = { ...defaults, ...object };\n```\n\nIf you already have an object containing default values, option 3 fits the nicest, but it can't be used as-is if you need the defaults to be applied against `undefined` and/or `null` fields. This can be handled by removing `undefined`/`null` from `object` before applying default values, as follows:\n\n```javascript\n// The behavior of this function can easily be tweaked if, for example,\n// you also wish to remove `null` fields from an object.\nfunction removeUndefinedProps(object) {\n  const filteredEntries = Object.entries(object)\n    .filter(([key, value]) => value !== undefined);\n\n  return Object.fromEntries(filteredEntries);\n}\n\nconst result = { ...defaults, ...removeUndefinedProps(object) };\n```\n\nNote that the Lodash implementation would pick both own and inherited properties from the default objects, while this third pattern of spreading objects does not. In practice, this shouldn't matter much because 1. Generally, your default objects won't have inherited fields, and 2. Even if they did, if those inherited fields are set up \"properly\" (i.e. the same way the class syntax automatically does for you), they should also be non-enumerable, and Lodash's `_.defaults()` does not pick non-enumerable fields from the defaults object.\n","src":null,"test":""},{"name":"defaultsDeep","manifest":{"fnSignature":"_.defaults(object, ...sources)","lodashLink":"https://lodash.com/docs/4.17.15#defaultsDeep","summary":"This method is like `_.defaults` except that it recursively assigns default properties."},"description":"There's a handful of different patterns that can be used when you need to apply default values deeply to your object. Each of these methods will handle `null`, `undefined`, and absent properties differently.\n\n1. Destructuring with defaults\n\nDefaults will be applied if the properties on `object` are absent or set to `undefined`.\n\n```javascript\nfunction addDefaultValues(object) {\n  const {\n    prop1 = 'default 1',\n    subObj = {\n      prop2 = 'default 2',\n      prop3 = 'default 3',\n    } = {},\n  } = object;\n\n  return { prop1, subObj: { prop2, prop3 } };\n}\n```\n\n2. Using the nullish coalescing operator (`??`)\n\nDefaults will be applied if the properties on `object` are absent, set to `undefined`, or set to `null`.\n\n```javascript\nconst result = {\n  prop1: object.prop1 ?? 'default 1',\n  subObj: {\n    prop2: object.subObj?.prop2 ?? 'default 2',\n    prop3: object.subObj?.prop3 ?? 'default 3',\n  },\n};\n```\n\n3. Spreading a defaults object with your target object\n\nDefaults will only be applied if the properties on `object` are absent.\n\n```javascript\nconst defaults = {\n  prop1: 'default 1',\n};\n\nconst subObjDefault = {\n  prop2: 'default 2',\n  prop3: 'default 3',\n};\n\nconst result = {\n  ...defaults,\n  ...object,\n  subObj: {\n    ...subObjDefaults,\n    ...object.subObj ?? {},\n  },\n};\n```\n\nIf you already have an object containing default values, option 3 fits the nicest, but it can't be used as-is if you need the defaults to be applied against `undefined` and/or `null` fields. This can be handled by removing `undefined`/`null` from `object` before applying default values, as follows:\n\n```javascript\n// The behavior of this function can easily be tweaked if, for example,\n// you also wish to remove `null` fields from an object.\nfunction removeUndefinedProps(object) {\n  const filteredEntries = Object.entries(object)\n    .filter(([key, value]) => value !== undefined);\n\n  return Object.fromEntries(filteredEntries);\n}\n\nconst result = {\n  ...defaults,\n  ...removeUndefinedProps(object),\n  subObj: {\n    ...subObjDefaults,\n    ...removeUndefinedProps(object.subObj ?? {}),\n  },\n};\n```\n\nFinally, if you don't feel any of these patterns will fit your use-case very well, you can use the following helper function, which mimics `_.defaultsDeep()`.\n\n```javascript\nconst isObject = value => value !== null && typeof value === 'object';\n\n// NOTE: This mutates `object`.\nfunction defaultsDeep(object, ...sources) {\n  for (const source of sources) {\n    for (const [key, value] of Object.entries(source)) {\n      if (object[key] === undefined) {\n        object[key] = value;\n      } else if (isObject(value) && isObject(source[key])) {\n        defaultsDeep(object[key], value);\n      }\n    }\n  }\n\n  return object;\n}\n```\n\nNote that the Lodash implementation would pick both own and inherited properties from the default objects, while this third pattern of spreading objects does not. In practice, this shouldn't matter much because 1. Generally, your default objects won't have inherited fields, and 2. Even if they did, if those inherited fields are set up \"properly\" (i.e. the same way the class syntax automatically does for you), they should also be non-enumerable, and Lodash's `_.defaultsDeep()` does not pick non-enumerable fields from the defaults object.\n","src":null,"test":""},{"name":"findKey","manifest":{"fnSignature":"_.findKey(object, predicate?)","lodashLink":"https://lodash.com/docs/4.17.15#findKey","summary":"This method is like `_.find` except that it returns the key of the first element predicate returns truthy for instead of the element itself."},"description":"```javascript\nObject.entries(object)\n  .find(([key, value]) => predicate(value))?.[0];\n```\n","src":null,"test":""},{"name":"findLastKey","manifest":{"fnSignature":"_.findKey(object, predicate?)","lodashLink":"https://lodash.com/docs/4.17.15#findKey","summary":"This method is like `_.find` except that it returns the key of the first element predicate returns truthy for instead of the element itself."},"description":"```javascript\nObject.entries(object)\n  .findLast(([key, value]) => predicate(value))?.[0];\n```\n","src":null,"test":""},{"name":"forIn","manifest":{"fnSignature":"_.forIn(object, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#forIn","summary":"Iterates over own and inherited enumerable string keyed properties of an object and invokes iteratee for each property. Iteratee functions may exit iteration early by explicitly returning `false`."},"description":"```javascript\nfor (const key in object) {\n  const value = object[key];\n  ...\n}\n```\n\nIt's very likely that you don't actually want this behavior. The only way this solution different from the solutions for `_.forOwn()`, is that it'll also iterate over non-enumerable inherited properties. But...\n1. Class syntax will automatically make all methods on the prototype chain non-enumerable, which means the for-in loop won't iterate over them anyways. Even if you achieve inheritance other ways (by manually messing with the prototypes), it can be argued that it's more proper to make the methods on the prototype non-enumerable.\n2. It's long been considered a good practice whenever using a for-in loop, to also check if the property you're iterating over is non-inherited, by nesting an `if (Object.prototype.hasOwnProperty.call(object, key)) { ... }` check into your loop. This was done, among other reasons, to guard against the case where someone may have improperly mutated `Object.prototype`, and added an enumerable property to it. This `for-in` + `is-own` check isn't seen as much in the wild anymore, because the language has since come out with a better way to inherit over non-inherited keys, which is discussed in the `_.forOwn()` entry.\n\nFor day-to-day development, it's best to stay away from the raw for-in loop. If you just want to iterate over object keys, and don't want to worry about inherited fields, look at `_.forOwn()` instead.\n","src":null,"test":""},{"name":"forInRight","manifest":{"fnSignature":"_.forInRight(object, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#forInRight","summary":"This method is like `_.forIn` except that it iterates over properties of `object` in the opposite order."},"description":"```javascript\nconst keys = [];\nfor (const key in object) {\n  keys.push(key);\n}\nkeys.reverse();\n\nfor (const key of keys) {\n  const value = object[key];\n  ...\n}\n```\n\nPlease don't actually use this solution.\n\nObjects are supposed to be treated as unordered collections. Yes, it's technically true that the JavaScript committee has standardized a stable ordering for object properties, but they only did this so your JavaScript programs will run exactly the same, no matter which engine they run on. They don't provide any tools to modify the ordering of an object (like, \"move this property, so that it's second in iteration order, instead of last\"), and the lack of these types of tools exist for a reason - they don't _want_ you to write code that relies on the order, nor does anyone trying to read and understand your code. Conceptually, objects are supposed to be unordered, please treat them that way. Because of this, there's no reason to iterate over an object from the end to the beginning, you should be able to just use `_.forIn()` instead of `_.forInRight()`.\n\nExcept, both `_.forIn()` and `_.forInRight()` have another problem.\n\nIt's very likely that you don't actually want to iterate over the enumerable, inherited properties, because:\n1. Class syntax will automatically make all methods on the prototype chain non-enumerable, which means the for-in loop won't iterate over them anyways. Even if you achieve inheritance other ways (by manually messing with the prototypes), it can be argued that it's more proper to make the methods on the prototype non-enumerable.\n2. It's long been considered a good practice whenever using a for-in loop, to also check if the property you're iterating over is non-inherited, by nesting an `if (Object.prototype.hasOwnProperty.call(object, key)) { ... }` check into your loop. This was done, among other reasons, to guard against the case where someone may have improperly mutated `Object.prototype`, and added an enumerable property to it. This `for-in` + `is-own` check isn't seen as much in the wild anymore, because the language has since come out with a better way to inherit over non-inherited keys, which is discussed in the `_.forOwn()` entry.\n\nIf you just want to iterate over object keys, and don't want to worry about inherited properties or the ordering of keys, look at `_.forOwn()` instead.\n","src":null,"test":""},{"name":"forOwn","manifest":{"fnSignature":"_.forOwn(object, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#forOwn","summary":"Iterates over own enumerable string keyed properties of an object and invokes `iteratee` for each property. Iteratee functions may exit iteration early by explicitly returning `false`."},"description":"If you wish to iterate over both keys and values:\n\n```javascript\nfor (const [key, value] of Object.entries(object)) {\n  ...\n}\n```\n\nIf, instead, you just want values, you can use `Object.values(object)`.\n\n```javascript\nfor (const value of Object.values(object)) {\n  ...\n}\n```\n\nAnd if you just want keys, you can use `Object.keys(object)`.\n\n```javascript\nfor (const key of Object.keys(object)) {\n  ...\n}\n```\n\nYou'll find the `.forEach()` method to be very popular in the JavaScript community as well.\n\n```javascript\nObject.entries(object).forEach(([key, value]) => {\n\n});\n```\n\nUsing `.forEach()` will certainly feel closer to Lodash's `_.forOwn()`, but it does have a number of drawbacks:\n* You can't use `break` in a `.forEach()`. (You can mimic `continue` via an early return).\n* `.forEach()` doesn't provide proper support for `await`. If you need to run tasks in parallel, use `await Promise.all(items.map(...))`, and if you want to run tasks in a series, you can just use a for-of loop.\n* `.forEach()` doesn't work with generators. You can't `yield` from inside a `.forEach()`.\n* `.forEach()` only works with arrays, and any other collection that happens to implement the `.forEach()` function. `for-of` works with all iterators, including strings, the legacy `arguments` object, your own iterators made via generator functions, etc.\n* `for-of` is newer than `.forEach()` and was intended to be the better version of `.forEach()`. It's a shame it's still struggling to gain traction.\n","src":null,"test":""},{"name":"forOwnRight","manifest":{"fnSignature":"_.forOwnRight(object, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#forOwnRight","summary":"This method is like `_.forOwn` except that it iterates over properties of `object` in the opposite order."},"description":"```javascript\nfor (const [key, value] of Object.entries(object).reverse()) {\n  ...\n}\n```\n\nPlease don't actually use this solution.\n\nObjects are supposed to be treated as unordered collections. Yes, it's technically true that the JavaScript committee has standardized a stable ordering for object properties, but they only did this so your JavaScript programs will run exactly the same, no matter which engine they run on. They don't provide any tools to modify the ordering of an object (like, \"move this property, so that it's second in iteration order, instead of last\"), and the lack of these types of tools exist for a reason - they don't _want_ you to write code that relies on the order, nor does anyone trying to read and understand your code. Conceptually, objects are supposed to be unordered, please treat them that way. Because of this, there's no reason to iterate over an object from the end to the beginning, you should be able to just use `_.forOwn()` instead of `_.forOwnRight()`.\n","src":null,"test":""},{"name":"functions","manifest":{"fnSignature":"_.functions(object)","lodashLink":"https://lodash.com/docs/4.17.15#functions","summary":"Creates an array of function property names from own enumerable properties of `object`."},"description":"```javascript\nfunction functions(object) {\n  const result = [];\n  for (const [key, value] of Object.entries(object)) {\n    if (typeof value === 'function') {\n      result.push(key);\n    }\n  }\n\n  return result;\n}\n```\n","src":null,"test":""},{"name":"functionsIn","manifest":{"fnSignature":"_.functionsIn(object)","lodashLink":"https://lodash.com/docs/4.17.15#functionsIn","summary":"Creates an array of function property names from own and inherited enumerable properties of object."},"description":"```javascript\nfunction functionsIn(object) {\n  const result = [];\n  for (const key in object) {\n    if (typeof object[key] === 'function') {\n      result.push(key);\n    }\n  }\n\n  return result;\n}\n```\n\nIt's very likely that you don't actually need this function. The only way this function is different from `_.functions()`, is that it'll also search for non-enumerable inherited fields. But class syntax will automatically make all methods on the prototype chain non-enumerable, which means the `functionsIn()` function won't look for them anyways. Even if you achieve inheritance other ways (by manually messing with the prototypes), it can be argued that it's more proper to make the methods on the prototype non-enumerable, i.e. if the methods were attached to the prototype \"properly\", the `functionsIn()` implementation wouldn't be able to find anything on there anyways, since they'd all be marked as non-enumerable.\n\nPerhaps there's some niche use-cases for this sort of function, that arise from using the prototype in abnormal or legacy ways, but, for day-to-day development, it's best to stay away from this function. If you just want to search for non-inherited function names, use `_.functions()` instead. If you need to get all non-enumerable, inherited method names, first double check how you're designing your program to see if, perhaps, there's a better way to approach the problem, and if not, you can use `Object.getOwnPropertyNames()` to get non-inherited, non-enumerable properties in combination with manually walking up the prototype chain to achieve your desired effect.\n","src":null,"test":""},{"name":"get","manifest":{"fnSignature":"_.get(object, path, defaultValue?)","lodashLink":"https://lodash.com/docs/4.17.15#get","summary":"Gets the value at `path` of `object`. If the resolved value is `undefined`, the `defaultValue` is returned in its place."},"description":"```javascript\nfunction get(object, path, defaultValue = undefined) {\n  // Optional string-path support.\n  // You can remove this `if` block if you don't need it.\n  if (typeof path === 'string') {\n    path = path.split(/[.\\[\\]\\\"]+/).filter(x => x);\n  }\n\n  if (path.length === 0) {\n    return object;\n  }\n\n  const [head, ...tail] = path;\n  if (!(head in object)) {\n    return defaultValue;\n  }\n\n  return get(object[head], tail, defaultValue);\n}\n```\n\nOne of the primary reasons Lodash's `_.get()` function was commonly used, was as a way to easily access a nested property without having to worry about in-between fields being undefined. This is now possible today using [optional chaining](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining) (`?.`) whenever you suspect a property might be undefined, and the [nullish coalescing operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing) to provide a default value.\n\nFor example, these two are effectively the same:\n\n```javascript\n_.get(obj, 'a.b', null);\n\nobj?.a?.b ?? null;\n```\n\nNote that the support for string paths in the above `get()` implementation isn't very robust. It'll take invalid-looking input, such as `\"prop1.[prop2\"`, ignore the invalid parts, and attempt to work with it anyways. Lodash's `_.get()` isn't all that different in this regard. If you really need support for string inputs, like this, it's recommended to build out your own mini-parser, according to your specific use-cases. For everyone else, there shouldn't be a real reason to need this capability with the modern syntax that JavaScript provides.\n","src":null,"test":""},{"name":"has","manifest":{"fnSignature":"_.has(object, path)","lodashLink":"https://lodash.com/docs/4.17.15#has","summary":"Checks if path is a direct property of object."},"description":"If you have a simple key, then `Object.hasOwn()` can be used to check if it's a non-inherited property.\n\n```javascript\nObject.hasOwn({}, 'toString'); // false\nObject.hasOwn({ toString() { return '{}' } }, 'toString'); // true\n```\n\nIf you have an array of path keys you wish to travel down, or perhaps, a string containing nested property access (like `x.y.z`), use this:\n\n```javascript\nfunction has(object, path) {\n  // Optional nested-property string support.\n  // You can remove this `if` block if you don't need it.\n  if (typeof path === 'string') {\n    path = path.split(/[.\\[\\]\\\"]+/).filter(x => x);\n  }\n\n  const [head, ...tail] = path;\n  if (!Object.hasOwn(object, head)) {\n    return false;\n  }\n\n  if (tail.length === 0) {\n    return true;\n  }\n\n  return has(object[head], tail);\n}\n```\n\nNote that the support for nested string paths in the above `has()` implementation isn't very robust. It'll take invalid-looking input, such as `\"prop1.[prop2\"`, ignore the invalid parts, and attempt to work with it anyways. Lodash's `_.has()` isn't all that different in this regard. If you really need support for nested string paths, it's recommended to build out your own mini-parser, according to your specific use-cases. For everyone else, there shouldn't be a real reason to need this capability. Just provide the path you desire as an array instead.\n\nIf you don't have dynamic strings being provided to you, and you don't need to do the \"is-not-inherited\" checks, then you can simply use the `in` operator with \"optional chaining\" (`?.`) to check for the existence of a nested property.\n\n```javascript\n'z' in object?.x?.y;\n```\n","src":null,"test":""},{"name":"hasIn","manifest":{"fnSignature":"_.hasIn(object, path)","lodashLink":"https://lodash.com/docs/4.17.15#hasIn","summary":"Checks if `path` is a direct or inherited property of `object`."},"description":"If you have a simple key, then the `in` operator can be used to check if the property is found in the object.\n\n```javascript\n'x' in { x: 2 }; // true\n'toString' in { x: 2 }; // true - `in` checks for inherited properties as well\n```\n\nIf you have an array of path keys you wish to travel down, or perhaps, a string containing nested property access (like `x.y.z`), use this:\n\n```javascript\nfunction hasIn(object, path) {\n  // Optional nested-property string support.\n  // You can remove this `if` block if you don't need it.\n  if (typeof path === 'string') {\n    path = path.split(/[.\\[\\]\\\"]+/).filter(x => x);\n  }\n\n  const [head, ...tail] = path;\n  if (!(head in object)) {\n    return false;\n  }\n\n  if (tail.length === 0) {\n    return true;\n  }\n\n  return hasIn(object[head], tail);\n}\n```\n\nOne of the primary reasons Lodash's `_.hasIn()` function was commonly used, was as a way to easily check if a nested property existed, without having to worry about in-between fields being undefined. This is now possible today using [optional chaining](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining) (`?.`) whenever you suspect a property might be undefined.\n\nFor example, these two are the same:\n\n```javascript\n_.hasIn(obj, 'a.b.c');\n\n'c' in obj?.a?.b;\n```\n\nNote that the support for nested string paths in the above `hasIn()` implementation isn't very robust. It'll take invalid-looking input, such as `\"prop1.[prop2\"`, ignore the invalid parts, and attempt to work with it anyways. Lodash's `_.hasIn()` isn't all that different in this regard. If you really need support for nested string paths, it's recommended to build out your own mini-parser, according to your specific use-cases. For everyone else, there shouldn't be a real reason to need this capability. Just provide the path you desire as an array instead.\n","src":null,"test":""},{"name":"invert","manifest":{"fnSignature":"_.invert(object)","lodashLink":"https://lodash.com/docs/4.17.15#invert","summary":"Creates an object composed of the inverted keys and values of object. If object contains duplicate values, subsequent values overwrite property assignments of previous values."},"description":"```javascript\nfunction invert(obj) {\n  const newObj = {};\n  for (const [key, value] of Object.entries(obj)) {\n    newObj[value] = key;\n  }\n  return newObj;\n}\n```\n","src":null,"test":""},{"name":"invertBy","manifest":{"fnSignature":"_.invertBy(object, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#invertBy","summary":"This method is like `_.invert` except that the inverted object is generated from the results of running each element of `object` thru `iteratee`. The corresponding inverted value of each inverted key is an array of keys responsible for generating the inverted value."},"description":"```javascript\nfunction invertBy(obj, iteratee=x=>x) {\n  const newObj = {};\n  for (const [key, value] of Object.entries(obj)) {\n    const newValue = iteratee(value);\n    newObj[newValue] ??= [];\n    newObj[newValue].push(key);\n  }\n  return newObj;\n}\n```\n","src":null,"test":""},{"name":"invoke","manifest":{"fnSignature":"_.invoke(object, path, ...args)","lodashLink":"https://lodash.com/docs/4.17.15#invoke","summary":"Invokes the method at `path` of `object`."},"description":"```javascript\nfunction invoke(object, path, ...args) {\n  // Optional string-path support.\n  // You can remove this `if` block if you don't need it.\n  if (typeof path === 'string') {\n    path = path.split(/[.\\[\\]\\\"]+/).filter(x => x);\n  }\n\n  const [head, ...tail] = path;\n  if (!(head in object)) {\n    return undefined;\n  }\n\n  if (tail.length === 0) {\n    return object[head](...args);\n  }\n\n  return invoke(object[head], tail, ...args);\n}\n```\n\nOne of the primary reasons Lodash's `_.invoke()` function was commonly used, was as a way to easily invoke a function nested in an object, without having to worry about in-between fields being undefined. This is now possible today using [optional chaining](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining) (`?.`) whenever you suspect a property might be undefined.\n\nFor example, these two are effectively the same:\n\n```javascript\n_.invoke(obj, 'subObj.fn', 2, 4);\n\nobj?.subObj?.fn?.(2, 4);\n```\n\nNote that the support for string paths in the above `invoke()` implementation isn't very robust. It'll take invalid-looking input, such as `\"prop1.[prop2\"`, ignore the invalid parts, and attempt to work with it anyways. Lodash's `_.invoke()` isn't all that different in this regard. If you really need support for string inputs, like this, it's recommended to build out your own mini-parser, according to your specific use-cases. For everyone else, there shouldn't be a real reason to need this capability with the modern syntax that JavaScript provides.\n","src":null,"test":""},{"name":"keys","manifest":{"fnSignature":"_.keys(object)","lodashLink":"https://lodash.com/docs/4.17.15#keys","summary":"Creates an array of the own enumerable property names of `object`."},"description":"```javascript\nObject.keys(object);\n```\n","src":null,"test":""},{"name":"keysIn","manifest":{"fnSignature":"_.keysIn(object)","lodashLink":"https://lodash.com/docs/4.17.15#keysIn","summary":"Creates an array of the own and inherited enumerable property names of `object`."},"description":"```javascript\nfunction keysIn(object) {\n  const keys = [];\n  for (let key in object) {\n    keys.push(key);\n  }\n\n  return keys;\n}\n```\n\nIt's very likely that you don't actually need this function. The only way this function is different from `_.keys()` (or `Object.keys()`), is that it'll also grab over non-enumerable inherited keys. But class syntax will automatically make all methods on the prototype chain non-enumerable, which means the `keysIn()` function won't consider those inherited methods anyways. Even if you achieve inheritance other ways (by manually messing with the prototypes), it can be argued that it's more proper to make the methods on the prototype non-enumerable.\n\nPerhaps there's some niche use-cases for this sort of function, that arise from using the prototype in abnormal or legacy ways, but, for day-to-day development, it's best to stay away from this function. If you just want to get the non-inherited keys from an object, use `Object.keys(object)` instead.\n","src":null,"test":""},{"name":"mapKeys","manifest":{"fnSignature":"_.mapKeys(object, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#mapKeys","summary":"The opposite of `_.mapValues`; this method creates an object with the same values as `object` and keys generated by running each own enumerable string keyed property of `object` thru `iteratee`."},"description":"```javascript\nfunction mapKeys(obj, iteratee) {\n  const newObj = {};\n  for (const [key, value] of Object.entries(obj)) {\n    const newKey = iteratee(value, key, obj);\n    newObj[newKey] = value;\n  }\n\n  return newObj;\n}\n```\n","src":null,"test":""},{"name":"mapValues","manifest":{"fnSignature":"_.mapValues(object, iteratee?)","lodashLink":"https://lodash.com/docs/4.17.15#mapValues","summary":"Creates an object with the same keys as `object` and values generated by running each own enumerable string keyed property of `object` thru `iteratee`."},"description":"```javascript\nfunction mapValues(obj, iteratee) {\n  const newObj = {};\n  for (const [key, value] of Object.entries(obj)) {\n    newObj[key] = iteratee(value, key, obj);\n  }\n\n  return newObj;\n}\n```\n","src":null,"test":""},{"name":"merge","manifest":{"fnSignature":"_.merge(object, ...sources)","lodashLink":"https://lodash.com/docs/4.17.15#merge","summary":"This method is like `_.assign` except that it recursively merges own and inherited enumerable string keyed properties of source objects into the destination object. Source properties that resolve to `undefined` are skipped if a destination value exists. Source objects are applied from left to right. Subsequent sources overwrite property assignments of previous sources."},"description":"If you know the shape of the objects you're wishing to merge, you can just use the spread syntax, like this:\n\n```javascript\nconst result = {\n  ...object1,\n  ...object2,\n  subObject: {\n    ...object1.subObject,\n    ...object2.subObject,\n  },\n};\n```\n\nOtherwise, the following `merge()` function can be used to roughly mirror Lodash's `_.merge()`.\n\n```javascript\nconst isObject = value => value !== null && typeof value === 'object';\n\n// A \"plain\" object is an object who's a direct instance of Object\n// (or, who has a null prototype).\nconst isPlainObject = value => {\n  if (!isObject(value)) return false;\n  const prototype = Object.getPrototypeOf(value);\n  return prototype === null || prototype === Object.prototype;\n};\n\n// NOTE: This mutates `object`.\n// It also may mutate anything that gets attached to `object` during the merge.\nfunction merge(object, ...sources) {\n  for (const source of sources) {\n    for (const [key, value] of Object.entries(source)) {\n      if (value === undefined) {\n        continue;\n      }\n\n      // These checks are a week attempt at mimicking the various edge-case behaviors\n      // that Lodash's `_.merge()` exhibits. Feel free to simplify and\n      // remove checks that you don't need.\n      if (!isPlainObject(value) && !Array.isArray(value)) {\n        object[key] = value;\n      } else if (Array.isArray(value) && !Array.isArray(object[key])) {\n        object[key] = value;\n      } else if (!isObject(object[key])) {\n        object[key] = value;\n      } else {\n        merge(object[key], value)\n      }\n    }\n  }\n\n  return object;\n}\n```\n\nNote that the Lodash implementation would pick both own and inherited properties from the default objects, while this implementation does not. In practice, this shouldn't matter much because 1. Generally, your default objects won't have inherited fields, and 2. Even if they did, if those inherited fields are set up \"properly\" (i.e. the same way the class syntax automatically does for you), they should also be non-enumerable, and Lodash's `_.merge()` does not pick non-enumerable fields from the defaults object.\n\nIf all you want to do is deeply merge some plain objects, and you don't need to worry about odd scenarios, like \"what happens when I merge an array with a number\", or, \"how does a Map instance get merged with a plain object\", then an implementation like this should be sufficient.\n\n```javascript\nconst isObject = value => value !== null && typeof value === 'object';\n\n// NOTE: This mutates `object`.\n// It also may mutate anything that gets attached to `object` during the merge.\nfunction merge(object, ...sources) {\n  if (!isObject(object)) {\n    throw new Error(`Expected ${object} to be an object.`)\n  }\n\n  for (const source of sources) {\n    for (const [key, value] of Object.entries(source)) {\n      if (value === undefined) {\n        continue;\n      }\n\n      if (object[key] === undefined) {\n        object[key] = value;\n      } else {\n        merge(object[key], value)\n      }\n    }\n  }\n\n  return object;\n}\n```\n","src":null,"test":""},{"name":"mergeWith","manifest":{"fnSignature":"_.mergeWith(object, ...sources, customizer)","lodashLink":"https://lodash.com/docs/4.17.15#mergeWith","summary":"This method is like `_.merge` except that it accepts `customizer` which is invoked to produce the merged values of the destination and source properties. If `customizer` returns `undefined`, merging is handled by the method instead."},"description":"```javascript\nconst isObject = value => value !== null && typeof value === 'object';\n\n// A \"plain\" object is an object who's a direct instance of Object\n// (or, who has a null prototype).\nconst isPlainObject = value => {\n  if (!isObject(value)) return false;\n  const prototype = Object.getPrototypeOf(value);\n  return prototype === null || prototype === Object.prototype;\n};\n\n// NOTE: This mutates `object`.\n// It also may mutate anything that gets attached to `object` during the merge.\nfunction mergeWith(object, sources, customizer) {\n  for (const source of sources) {\n    for (const [key, value] of Object.entries(source)) {\n      const mergedValue = customizer(object[key], value, key, object, source, stack);\n      if (mergedValue !== undefined) {\n        object[key] = mergedValue;\n        continue;\n      }\n      // Otherwise, fall back to default behavior\n\n      if (value === undefined) {\n        continue;\n      }\n\n      // These checks are a week attempt at mimicking the various edge-case behaviors\n      // that Lodash's `_.merge()` exhibits. Feel free to simplify and\n      // remove checks that you don't need.\n      if (!isPlainObject(value) && !Array.isArray(value)) {\n        object[key] = value;\n      } else if (Array.isArray(value) && !Array.isArray(object[key])) {\n        object[key] = value;\n      } else if (!isObject(object[key])) {\n        object[key] = value;\n      } else {\n        mergeWith(object[key], value, customizer)\n      }\n    }\n  }\n\n  return object;\n}\n```\n\nNote that the Lodash implementation would pick both own and inherited properties from the default objects, while this implementation does not. In practice, this shouldn't matter much because 1. Generally, your default objects won't have inherited fields, and 2. Even if they did, if those inherited fields are set up \"properly\" (i.e. the same way the class syntax automatically does for you), they should also be non-enumerable, and Lodash's `_.merge()` does not pick non-enumerable fields from the defaults object.\n\nIn Lodash, the customizer function would be called with a sixth \"stack\" argument. Some probing shows that it's an instance of an internal \"Stack\" class, that provides some methods which, presumably, can be used to gather information about the objects you're merging. Due to the fact that this seems to be a rather complex feature that's entirely undocumented, it'll be assumed that the vast majority of users do not use this parameter, and so it's functionality won't be recreated here in vanilla JavaScript either.\n","src":null,"test":""},{"name":"omit","manifest":{"fnSignature":"_.omit(object, ...paths)","lodashLink":"https://lodash.com/docs/4.17.15#omit","summary":"This method is like `_.merge` except that it accepts `customizer` which is invoked to produce the merged values of the destination and source properties. If `customizer` returns `undefined`, merging is handled by the method instead."},"description":"If the properties you wish to omit are known in advance, you can use destructuring to omit them (possibly putting this in a helper function, to avoid polluting your scope with unnecessary variables).\n\n```javascript\n// `partialObject` will contain everything that's in `object`,\n// except, `propA` and `propB` will be omitted.\nconst { propA, propB, ...partialObject } = object;\n```\n\nIf you need to also omit nested properties, a similar pattern can still be followed.\n\n```javascript\n// omit properties from `object`\nconst { propA, propB, nestedObj, ...partialObject } = object;\n\n// omit properties from `object.nestedObj`\nconst { nestedPropA, ...partialNestedObject } = nestedObj;\n\n// Combine the two partial objects, to build the final result.\nconst result = { ...partialObject, partialNestedObject };\n```\n\nIf you don't know the keys you need to remove in advance, the following helper function can be utilized.\n\n```javascript\nfunction omit(object, keys_) {\n  const keys = new Set(keys_);\n  const newObject = {};\n  for (const [key, value] of Object.entries(object)) {\n    if (!keys.has(key)) {\n      newObject[key] = value;\n    }\n  }\n\n  return newObject;\n}\n```\n\nThere is an early [Object.omit() proposal](https://github.com/tc39/proposal-object-pick-or-omit), which, if implemented, would provide functionality similar to the above helper function.\n\nIf you need a version of the omit function that can omit nested properties, you can use this:\n\n```javascript\nconst isObject = value => typeof value === 'object' && value !== null;\n\nfunction omit(object, keys) {\n  const newObject = Array.isArray(object) ? [ ...object ] : { ...object };\n\n  for (const key of keys) {\n    let keyPath;\n    if (typeof key === 'string') {\n      // Optional string-path support.\n      // You can remove this key.split() stuff, and simply use `keyPath = [key];`\n      // if you don't need it.\n      keyPath = key.split(/[.\\[\\]\\\"]+/).filter(x => x);\n    } else if (Array.isArray(key)) {\n      keyPath = key;\n    } else {\n      throw new Error(`Received a key ${key}, which is of an invalid type.`);\n    }\n\n    const [head, ...tail] = keyPath;\n    if (tail.length === 0) {\n      delete newObject[key];\n    } else if (isObject(newObject[head]) || Array.isArray(newObject[head])) {\n      newObject[head] = omit(newObject[head], [tail]);\n    }\n  }\n\n  return newObject;\n}\n```\n\nIf you're only passing in a handful of keys at a time, the above implementation should work just fine, but if you think your keys array may become fairly large, you may need to do some work to optimize the above implementation a bit.\n\nNote that the support for string paths (e.g. keys like `key.nestedKey`) in the above `omit()` implementation isn't very robust. It'll take invalid-looking input, such as `\"prop1.[prop2\"`, ignore the invalid parts, and attempt to work with it anyways. Lodash's `_.omit()` isn't all that different in this regard. If you really need support for string-path inputs, like this, it's recommended to build out your own mini-parser, according to your specific use-cases. For everyone else, there shouldn't be a real reason to need this capability.\n\nNote that none of these implementations will actually copy non-enumerable properties from the prototype chain like Lodash's `_.omit()`. It's very likely that you don't actually want this kind of behavior anyways. Generally, all properties found on the prototype chain should be marked as enumerable (this is the default for class syntax) - this is standard practice, and there's really no reason to create a prototype with non-enumerable properties, with the possible exception of dealing with classes that were created before the class syntax came out, where the authors didn't want to put in the work of manually marking each method on the prototype as non-enumerable (it wasn't a common thing to do back in the day, even if it would have technically been more proper).\n","src":null,"test":""},{"name":"omitBy","manifest":{"fnSignature":"_.omitBy(object, predicate?)","lodashLink":"https://lodash.com/docs/4.17.15#omitBy","summary":"The opposite of `_.pickBy`; this method creates an object composed of the own and inherited enumerable string keyed properties of `object` that `predicate` doesn't return truthy for."},"description":"```javascript\nfunction omitBy(object, predicate) {\n  const newObject = {};\n  for (const [key, value] of Object.entries(object)) {\n    if (!predicate(value, key)) {\n      newObject[key] = value;\n    }\n  }\n\n  return newObject;\n}\n```\n\n`_.omitBy(object, x => <condition>)` is exactly the same as `_.pickBy(object, x => !<condition>)`. This means, you only really need one of these helper functions, not both.\n\nThere is also an early [Object.omit() proposal](https://github.com/tc39/proposal-object-pick-or-omit), which, if implemented, would provide functionality similar to the above helper function.\n\nNote that this implementation will not actually copy non-enumerable properties from the prototype chain like Lodash's `_.omitBy()`. It's very likely that you don't actually want this kind of behavior anyways. Generally, all properties found on the prototype chain should be marked as enumerable (this is the default for class syntax) - this is standard practice, and there's really no reason to create a prototype with non-enumerable properties, with the possible exception of dealing with classes that were created before the class syntax came out, where the authors didn't want to put in the work of manually marking each method on the prototype as non-enumerable (it wasn't a common thing to do back in the day, even if it would have technically been more proper).\n","src":null,"test":""},{"name":"pick","manifest":{"fnSignature":"_.pick(object, ...paths)","lodashLink":"https://lodash.com/docs/4.17.15#pick","summary":"Creates an object composed of the picked `object` properties."},"description":"If the properties you wish to pick are known in advance, you can use destructuring to pick them (possibly putting this in a helper function, to avoid polluting your scope with unnecessary variables).\n\n```javascript\nconst { propA, propB } = object;\nconst newObject = { propA, propB };\n```\n\nIf you need to also omit nested properties, a similar pattern can still be followed.\n\n```javascript\n// omit properties from `object`\nconst { propA, propB, nestedObj, ...partialObject } = object;\n\n// omit properties from `object.nestedObj`\nconst { nestedPropA, ...partialNestedObject } = nestedObj;\n\n// Combine the two partial objects, to build the final result.\nconst result = { ...partialObject, partialNestedObject };\n```\n\nIf you don't know the keys you need to pick in advance, the following helper function can be utilized.\n\n```javascript\nfunction pick(object, keys) {\n  const newObject = {};\n  for (const key of keys) {\n    if (key in object) {\n      if (key in object) {\n        newObject[key] = object[key];\n      }\n    }\n  }\n\n  return newObject;\n}\n```\n\nThere is an early [Object.pick() proposal](https://github.com/tc39/proposal-object-pick-or-omit), which, if implemented, would provide functionality similar to the above helper function.\n\nIf you need a version of the pick function that can pick nested properties, you can use this:\n\n```javascript\nconst isObject = value => typeof value === 'object' && value !== null;\n\nfunction pick(object, keys) {\n  if (object == null) {\n    return {};\n  }\n  const newObject = {};\n\n  for (const key of keys) {\n    let keyPath;\n    if (typeof key === 'string') {\n      // Optional string-path support.\n      // You can remove this key.split() stuff, and simply use `keyPath = [key];`\n      // if you don't need it.\n      keyPath = key.split(/[.\\[\\]\\\"]+/).filter(x => x);\n    } else if (Array.isArray(key)) {\n      keyPath = key;\n    } else {\n      throw new Error(`Received a key ${key}, which is of an invalid type.`);\n    }\n\n    const [head, ...tail] = keyPath;\n    if (!(head in object)) {\n      continue;\n    } else if (tail.length === 0) {\n      newObject[key] = object[key];\n    } else if (isObject(object[head]) || Array.isArray(object[head])) {\n      newObject[head] = {\n        ...newObject[head] ?? {},\n        ...pick(object[head], [tail])\n      };\n    }\n  }\n\n  return newObject;\n}\n```\n\nIf you're only passing in a handful of keys at a time, the above implementation should work just fine, but if you think your keys array may become fairly large, you may need to do some work to optimize the above implementation a bit.\n\nNote that the support for string paths (e.g. keys like `key.nestedKey`) in the above `pick()` implementation isn't very robust. It'll take invalid-looking input, such as `\"prop1.[prop2\"`, ignore the invalid parts, and attempt to work with it anyways. Lodash's `_.pick()` isn't all that different in this regard. If you really need support for string-path inputs, like this, it's recommended to build out your own mini-parser, according to your specific use-cases. For everyone else, there shouldn't be a real reason to need this capability.\n\nIn all of these implementations, you'll be able to pick own properties and inherited properties. This can lead to issues if you accept arbitrary untrusted user input in your keys array. For example, even though the object passed into `pick({}, [untrustedUserInput])` is empty, you can still pick inherited methods off of it, e.g. if untrustedUserInput is set to `'toString'`, you'd pick the `'toString'` method off of the empty object.","src":null,"test":""},{"name":"pickBy","manifest":{"fnSignature":"_.pickBy(object, predicate?)","lodashLink":"https://lodash.com/docs/4.17.15#pickBy","summary":"Creates an object composed of the object properties `predicate` returns truthy for. "},"description":"```javascript\nfunction pickBy(object, predicate) {\n  const newObject = {};\n  for (const [key, value] of Object.entries(object)) {\n    if (predicate(value, key)) {\n      newObject[key] = value;\n    }\n  }\n\n  return newObject;\n}\n```\n\nThere is also an early [Object.pick() proposal](https://github.com/tc39/proposal-object-pick-or-omit), which, if implemented, would provide functionality similar to the above helper function.\n\nNote that this implementation will not actually copy non-enumerable properties from the prototype chain like Lodash's `_.pickBy()`. It's very likely that you don't actually want this kind of behavior anyways. Generally, all properties found on the prototype chain should be marked as enumerable (this is the default for class syntax) - this is standard practice, and there's really no reason to create a prototype with non-enumerable properties, with the possible exception of dealing with classes that were created before the class syntax came out, where the authors didn't want to put in the work of manually marking each method on the prototype as non-enumerable (it wasn't a common thing to do back in the day, even if it would have technically been more proper).\n","src":null,"test":""},{"name":"result","manifest":{"fnSignature":"_.result(object, path, defaultValue?)","lodashLink":"https://lodash.com/docs/4.17.15#result","summary":"This method is like `_.get` except that if the resolved value is a function it's invoked with the `this` binding of its parent object and its result is returned."},"description":"```javascript\nfunction result(object, path, defaultValue = undefined) {\n  // Optional string-path support.\n  // You can remove this `if` block if you don't need it.\n  if (typeof path === 'string') {\n    path = path.split(/[.\\[\\]\\\"]+/).filter(x => x);\n  }\n\n  const [head, ...tail] = path;\n  if (!(head in object)) {\n    return defaultValue;\n  }\n\n  if (tail.length === 0) {\n    return object[head]();\n  }\n\n  return result(object[head], tail, defaultValue);\n}\n```\n\nOne of the primary reasons Lodash's `_.result()` function was commonly used, was as a way to easily invoke a function nested in an object, without having to worry about in-between fields being undefined. This is now possible today using [optional chaining](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining) (`?.`) whenever you suspect a property might be undefined, and the [nullish coalescing operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing) to provide a default value.\n\nFor example, these two are effectively the same:\n\n```javascript\n_.result(obj, 'subObj.fn', 'fallback');\n\nobj?.subObj?.fn?.() ?? 'fallback';\n```\n\nNote that the support for string paths in the above `result()` implementation isn't very robust. It'll take invalid-looking input, such as `\"prop1.[prop2\"`, ignore the invalid parts, and attempt to work with it anyways. Lodash's `_.result()` isn't all that different in this regard. If you really need support for string inputs, like this, it's recommended to build out your own mini-parser, according to your specific use-cases. For everyone else, there shouldn't be a real reason to need this capability with the modern syntax that JavaScript provides.\n","src":null,"test":""},{"name":"set","manifest":{"fnSignature":"_.set(object, path, value)","lodashLink":"https://lodash.com/docs/4.17.15#set","summary":"Sets the value at `path` of `object`. If a portion of `path` doesn't exist, it's created. Arrays are created for missing index properties while objects are created for all other missing properties."},"description":"```javascript\nfunction set(object, path, value) {\n  // Optional string-path support.\n  // You can remove this `if` block if you don't need it.\n  if (typeof path === 'string') {\n    const isQuoted = str => str[0] === '\"' && str.at(-1) === '\"';\n    path = path.split(/[.\\[\\]]+/)\n      .filter(x => x)\n      .map(x => !isNaN(Number(x)) ? Number(x) : x)\n      .map(x => typeof x === 'string' && isQuoted(x) ? x.slice(1, -1) : x);\n  }\n\n  if (path.length === 0) {\n    throw new Error('The path must have at least one entry in it');\n  }\n\n  const [head, ...tail] = path;\n\n  if (tail.length === 0) {\n    object[head] = value;\n    return object;\n  }\n\n  if (!(head in object)) {\n    object[head] = typeof tail[0] === 'number' ? [] : {};\n  }\n\n  set(object[head], tail, value);\n  return object;\n}\n```\n\nOne of the primary reasons Lodash's `_.set()` function was commonly used, was as a way to easily update a nested property without having to worry about in-between fields being undefined. This is now possible today using [optional chaining](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining) (`?.`) whenever you suspect a property might be undefined.\n\nFor example, these two accomplish the same objective:\n\n```javascript\n_.set(obj, 'a.b.c', true);\n\nif (obj?.a?.b) {\n  obj.a.b.c = true;\n}\n```\n\nNote that the support for string paths in the above `set()` implementation isn't very robust. It'll take invalid-looking input, such as `\"prop1.[prop2\"`, ignore the invalid parts, and attempt to work with it anyways. Lodash's `_.set()` isn't all that different in this regard. If you really need support for string inputs, like this, it's recommended to build out your own mini-parser, according to your specific use-cases. For everyone else, there shouldn't be a real reason to need this capability with the modern syntax that JavaScript provides.\n","src":null,"test":""},{"name":"setWith","manifest":{"fnSignature":"_.setWith(object, path, value, customizer?)","lodashLink":"https://lodash.com/docs/4.17.15#setWith","summary":"This method is like `_.set` except that it accepts `customizer` which is invoked to produce the objects of `path`. If `customizer` returns `undefined` path creation is handled by the method instead."},"description":"```javascript\nfunction setWith(object, path, value, customizer) {\n  // Optional string-path support.\n  // You can remove this `if` block if you don't need it.\n  if (typeof path === 'string') {\n    const isQuoted = str => str[0] === '\"' && str.at(-1) === '\"';\n    path = path.split(/[.\\[\\]]+/)\n      .filter(x => x)\n      .map(x => !isNaN(Number(x)) ? Number(x) : x)\n      .map(x => typeof x === 'string' && isQuoted(x) ? x.slice(1, -1) : x);\n  }\n\n  if (path.length === 0) {\n    throw new Error('The path must have at least one entry in it');\n  }\n\n  const [head, ...tail] = path;\n\n  if (tail.length === 0) {\n    object[head] = value;\n    return object;\n  }\n\n  let pathSegment = customizer(object[head], head, object);\n\n  if (pathSegment !== undefined) {\n    object[head] = pathSegment;\n  } else if (!(head in object)) {\n    object[head] = typeof tail[0] === 'number' ? [] : {};\n  }\n\n  setWith(object[head], tail, value, customizer);\n  return object;\n}\n```\n\nNote that the support for string paths in the above `setWith()` implementation isn't very robust. It'll take invalid-looking input, such as `\"prop1.[prop2\"`, ignore the invalid parts, and attempt to work with it anyways. Lodash's `_.setWith()` isn't all that different in this regard. If you really need support for string inputs, like this, it's recommended to build out your own mini-parser, according to your specific use-cases. For everyone else, there shouldn't be a real reason to need this capability, since you can always provide an array of keys to form a path, instead of a dot-separated string.\n","src":null,"test":""},{"name":"toPairs","manifest":{"fnSignature":"_.toPairs(object)","lodashLink":"https://lodash.com/docs/4.17.15#toPairs","summary":"Creates an array of own enumerable string keyed-value pairs for `object` which can be consumed by `_.fromPairs`. If object is a map or set, its entries are returned."},"description":"If you have a normal object, use `Object.entries(object);`.\n\nIf you have a map, use `[...map]`.\n\nAnd, while it's not all that useful, you can get the contents of a set, formatted in pairs the same way Lodash's `_.toPairs()` does it, as follows:\n\n```javascript\n[...set].map(value => [value, value]);\n```\n","src":null,"test":""},{"name":"toPairsIn","manifest":{"fnSignature":"_.toPairsIn(object)","lodashLink":"https://lodash.com/docs/4.17.15#toPairsIn","summary":"Creates an array of own and inherited enumerable string keyed-value pairs for `object` which can be consumed by `_.fromPairs`. If `object` is a map or set, its entries are returned."},"description":"If you have a normal object, the following:\n\n```javascript\nfunction toPairsIn(object) {\n  const pairs = [];\n  for (let key in object) {\n    pairs.push([key, object[key]]);\n  }\n\n  return pairs;\n}\n```\n\nIf you have a map, use `[...map]`.\n\nAnd, while it's not all that useful, you can get the contents of a set, formatted in pairs the same way Lodash's `_.toPairs()` does it, as follows:\n\n```javascript\n[...set].map(value => [value, value]);\n```\n\nIt's very likely that you don't actually need the above `toPairsIn()` function. The only way this function is different from `_.toPairs()` (or `Object.entries()`), is that it'll also operate on non-enumerable inherited fields. But class syntax will automatically make all methods on the prototype chain non-enumerable, which means the `toPairsIn()` function won't operate on them anyways. Even if you achieve inheritance other ways (by manually messing with the prototypes), it can be argued that it's more proper to make the methods on the prototype non-enumerable.\n\nPerhaps there's some niche use-cases for this sort of function that arise from fairly abnormal and tricky uses of the JavaScript prototype, but, for day-to-day development, it's best to stay away from this function. If you just want to get a list of non-inherited pairs (entries), please look at `_.toPairs()` instead.\n","src":null,"test":""},{"name":"transform","manifest":{"fnSignature":"_.transform(object)","lodashLink":"https://lodash.com/docs/4.17.15#transform","summary":"An alternative to `_.reduce`; this method transforms `object` to a new `accumulator` object which is the result of running each of its own enumerable string keyed properties thru `iteratee`, with each invocation potentially mutating the `accumulator` object. If `accumulator` is not provided, a new object with the same `[[Prototype]]` will be used."},"description":"Using `_.transform()` really isn't any different from using the built-in `array.reduce()` method, except for a couple of minor things.\n\n1. With `array.reduce()`, you need to always return the accumulator\n2. If you're dealing with objects, you need to use `Object.entries(yourObject)` to turn it into an array of tuples first.\n\nWhat this looks like in practice, using an example from Lodash's website.\n\n```javascript\n_.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {\n  (result[value] || (result[value] = [])).push(key);\n}, {});\n// => { '1': ['a', 'c'], '2': ['b'] }\n\n// Note the use of `Object.entries()` (point 1) here.\nObject.entries({ 'a': 1, 'b': 2, 'c': 1 }).reduce((result, [key, value]) => {\n  (result[value] || (result[value] = [])).push(key);\n  return result; // Note how we return the accumulator (point 2) here.\n}, {});\n```\n\nA simple for loop will work just as well, if that's your preference.\n\n```javascript\nconst result = {};\nfor (const [key, value] of Object.entries({ 'a': 1, 'b': 2, 'c': 1 })) {\n  (result[value] || (result[value] = [])).push(key);\n}\n```","src":null,"test":""},{"name":"unset","manifest":{"fnSignature":"_.unset(object, path)","lodashLink":"https://lodash.com/docs/4.17.15#unset","summary":"Removes the property at `path` of `object`."},"description":"```javascript\nfunction unset(object, path) {\n  // Optional string-path support.\n  // You can remove this `if` block if you don't need it.\n  if (typeof path === 'string') {\n    const isQuoted = str => str[0] === '\"' && str.at(-1) === '\"';\n    path = path.split(/[.\\[\\]]+/)\n      .filter(x => x)\n      .map(x => !isNaN(Number(x)) ? Number(x) : x)\n      .map(x => typeof x === 'string' && isQuoted(x) ? x.slice(1, -1) : x);\n  }\n\n  if (path.length === 0) {\n    throw new Error('The path must have at least one entry in it');\n  }\n\n  const [head, ...tail] = path;\n\n  if (tail.length === 0) {\n    delete object[head];\n  } else if (head in object) {\n    unset(object[head], tail);\n  }\n\n  return object;\n}\n```\n\nOne of the primary reasons Lodash's `_.unset()` function was commonly used, was as a way to easily delete a nested property without having to worry about in-between fields being undefined. This is now possible today using [optional chaining](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining) (`?.`) whenever you suspect a property might be undefined.\n\nFor example, these two are the same:\n\n```javascript\n_.unset(obj, 'a.b');\n\ndelete obj?.a?.b;\n```\n\nNote that the support for string paths in the above `unset()` implementation isn't very robust. It'll take invalid-looking input, such as `\"prop1.[prop2\"`, ignore the invalid parts, and attempt to work with it anyways. Lodash's `_.unset()` isn't all that different in this regard. If you really need support for string inputs, like this, it's recommended to build out your own mini-parser, according to your specific use-cases. For everyone else, there shouldn't be a real reason to need this capability with the modern syntax that JavaScript provides.\n","src":null,"test":""},{"name":"update","manifest":{"fnSignature":"_.set(object, path, value)","lodashLink":"https://lodash.com/docs/4.17.15#set","summary":"Sets the value at `path` of `object`. If a portion of `path` doesn't exist, it's created. Arrays are created for missing index properties while objects are created for all other missing properties."},"description":"```javascript\nfunction update(object, path, updater) {\n  // Optional string-path support.\n  // You can remove this `if` block if you don't need it.\n  if (typeof path === 'string') {\n    const isQuoted = str => str[0] === '\"' && str.at(-1) === '\"';\n    path = path.split(/[.\\[\\]]+/)\n      .filter(x => x)\n      .map(x => !isNaN(Number(x)) ? Number(x) : x)\n      .map(x => typeof x === 'string' && isQuoted(x) ? x.slice(1, -1) : x);\n  }\n\n  if (path.length === 0) {\n    throw new Error('The path must have at least one entry in it');\n  }\n\n  const [head, ...tail] = path;\n\n  if (tail.length === 0) {\n    object[head] = updater();\n    return object;\n  }\n\n  if (!(head in object)) {\n    object[head] = typeof tail[0] === 'number' ? [] : {};\n  }\n\n  update(object[head], tail, updater);\n  return object;\n}\n```\n\nOne of the primary reasons Lodash's `_.update()` function was commonly used, was as a way to easily update a nested property without having to worry about in-between fields being undefined. This is now possible today using [optional chaining](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining) (`?.`) whenever you suspect a property might be undefined.\n\nFor example, these two accomplish the same objective:\n\n```javascript\n_.update(obj, 'a.b.c', () => new Something());\n\nif (obj?.a?.b) {\n  obj.a.b.c = new Something();\n}\n```\n\nNote that the support for string paths in the above `update()` implementation isn't very robust. It'll take invalid-looking input, such as `\"prop1.[prop2\"`, ignore the invalid parts, and attempt to work with it anyways. Lodash's `_.update()` isn't all that different in this regard. If you really need support for string inputs, like this, it's recommended to build out your own mini-parser, according to your specific use-cases. For everyone else, there shouldn't be a real reason to need this capability with the modern syntax that JavaScript provides.\n","src":null,"test":""},{"name":"updateWith","manifest":{"fnSignature":"_.updateWith(object, path, updater, customizer?)","lodashLink":"https://lodash.com/docs/4.17.15#set","summary":"This method is like `_.update` except that it accepts `customizer` which is invoked to produce the objects of `path`. If `customizer` returns `undefined` path creation is handled by the method instead."},"description":"```javascript\nfunction updateWith(object, path, updater, customizer) {\n  // Optional string-path support.\n  // You can remove this `if` block if you don't need it.\n  if (typeof path === 'string') {\n    const isQuoted = str => str[0] === '\"' && str.at(-1) === '\"';\n    path = path.split(/[.\\[\\]]+/)\n      .filter(x => x)\n      .map(x => !isNaN(Number(x)) ? Number(x) : x)\n      .map(x => typeof x === 'string' && isQuoted(x) ? x.slice(1, -1) : x);\n  }\n\n  if (path.length === 0) {\n    throw new Error('The path must have at least one entry in it');\n  }\n\n  const [head, ...tail] = path;\n\n  if (tail.length === 0) {\n    object[head] = updater();\n    return object;\n  }\n\n  let pathSegment = customizer(object[head], head, object);\n\n  if (pathSegment !== undefined) {\n    object[head] = pathSegment;\n  } else if (!(head in object)) {\n    object[head] = typeof tail[0] === 'number' ? [] : {};\n  }\n\n  updateWith(object[head], tail, updater, customizer);\n  return object;\n}\n```\n\nNote that the support for string paths in the above `updateWith()` implementation isn't very robust. It'll take invalid-looking input, such as `\"prop1.[prop2\"`, ignore the invalid parts, and attempt to work with it anyways. Lodash's `_.updateWith()` isn't all that different in this regard. If you really need support for string inputs, like this, it's recommended to build out your own mini-parser, according to your specific use-cases. For everyone else, there shouldn't be a real reason to need this capability with the modern syntax that JavaScript provides.\n","src":null,"test":""},{"name":"values","manifest":{"fnSignature":"_.values(object)","lodashLink":"https://lodash.com/docs/4.17.15#values","summary":"Creates an array of the own enumerable string keyed property values of `object`."},"description":"```javascript\nObject.values(object);\n```\n","src":null,"test":""},{"name":"valuesIn","manifest":{"fnSignature":"_.valuesIn(object)","lodashLink":"https://lodash.com/docs/4.17.15#valuesIn","summary":"Creates an array of the own and inherited enumerable string keyed property values of `object`."},"description":"```javascript\nfunction valuesIn(object) {\n  const values = [];\n  for (let key in object) {\n    values.push(object[key]);\n  }\n\n  return values;\n}\n```\n\nIt's very likely that you don't actually need the above `valuesIn()` function. The only way this function is different from `_.values()` (or `Object.values()`), is that it'll also operate on non-enumerable inherited fields. But class syntax will automatically make all methods on the prototype chain non-enumerable, which means the `valuesIn()` function won't operate on them anyways. Even if you achieve inheritance other ways (by manually messing with the prototypes), it can be argued that it's more proper to make the methods on the prototype non-enumerable.\n\nPerhaps there's some niche use-cases for this sort of function that arise from fairly abnormal and tricky uses of the JavaScript prototype, but, for day-to-day development, it's best to stay away from this function. If you just want to get an object's non-inherited property values, please look at `_.values()` instead.\n","src":null,"test":""}]}]